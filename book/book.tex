\documentclass[fontset=windows]{ctexart}
\usepackage{amsmath,amssymb}
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{fullpage}
\usepackage{setspace}
\usepackage{verbatim}
\usepackage[colorlinks,linkcolor=blue]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{xeCJK}
\setmainfont{Times New Roman}
% \setCJKmainfont{SimSun}
\setCJKmonofont{Consolas}
\newCJKfontfamily[kai]\kaiti{KaiTi}
\newCJKfontfamily[HWkai]\hwkaiti{STKaiti}
% \newCJKfontfamily[hei]\heiti{SimHei}
% \newCJKfontfamily[song]\songti{SimSun}
\newfontfamily\consolas{Consolas}
\lstset{
    columns=fixed,       
%    numbers=left,                                        % 在左侧显示行号
	frame=none,                                          % 不显示背景边框
	basicstyle=\consolas,
    backgroundcolor=\color[RGB]{245,245,244},            % 设定背景颜色
    keywordstyle=\consolas\color[RGB]{40,40,255},                 % 设定关键字颜色
	numberstyle=\consolas\color[RGB]{0,255,0},           % 设定行号格式
    commentstyle=\hwkaiti\consolas\color[RGB]{0,96,96},                % 设置代码注释的格式
    stringstyle=\consolas\color[RGB]{255,0,0},   % 设置字符串格式
    showstringspaces=false,                              % 不显示字符串中的空格
    %language=c++,                                        % 设置语言
}
\onehalfspacing
\title{\bf\huge 计算机图形学基础教程}
\author{清华大学\ 计算机科学与技术系}
\date{\today}

\begin{document}
\maketitle

%\hwkaiti{}
% \renewcommand{\contentsname}{目录}
% \renewcommand{\figurename}{图 }

\tableofcontents

\newpage

\section{OpenGL 教程}

\subsection{OpenGL 概述}

\emph{}

OpenGL 是一套开放标准的跨平台高性能图形 API，可以帮助使用者快速创建高性能图形应用程序。
自发布以来，OpenGL 由于其开放性、易用性、可移植性等诸多优点，被广泛地应用在各类图形软件中。

OpenGL的前身是美国硅图公司（Silicon Graphics Inc, SGI）为其图形工作站开发的专有图形接口 IRIS GL。
由于当时不同组织设计的图形硬件设备使用的接口都是专有化的，
图形软件开发者不得不为每种硬件编写不同的代码，
这使得开发图形软件的成本十分昂贵。
20世纪90年代初，SGI 公司意识到了可移植性的重要性，针对性地修改了 IRIS GL 的接口，
移除了其中与特定系统相关的内容，将其作为开放标准发布，即 OpenGL。

1992 年 OpenGL 1.0 版本发布，之后历经二十余年的发展，迭代至今已发布至 4.6 版本。
其维护组织也从 OpenGL 架构审查委员会（OpenGL ARB）转为 Khronos Group。
随着计算机图形硬件的发展，现代图形 API 也逐渐向更加通用的计算发展。
如今，OpenGL 已经几乎停止更新，Khronos Group于2015年发布了其继任者 Vulkan API 标准。
新的标准采用了更底层，更灵活的接口设计，更加适应现代的程序开发模式。
但由于新的接口标准过于复杂，涉及到许多硬件资源的管理问题，对于图形学学习者并不够友好。
OpenGL 在图形应用方面提供了足够强的通用性，并保持着足够好的易用性，
因此其依然是许多情况下最合适的选择。

\subsection{OpenGL 开发环境搭建}

\subsubsection{OpenGL 库}

\emph{}

由于 OpenGL 是一个开放标准，
这使得其接口函数的实现是由不同的图形硬件厂商（如：NVIDIA，AMD，Intel，等）
通过各自的硬件驱动程序提供的。

这样的情况导致许多初学者找不到调用 OpenGL 的方法，因为并不存在一个叫做 OpenGL 的库。
想要调用 OpenGL 函数，必须先从硬件驱动程序中提取出 OpenGL 函数接口。
但由于硬件厂商可能存在不同，驱动程序的位置也往往是不确定的，这给开发者带来了很大的困扰。
针对这个问题，诞生了许多第三方库。
这些第三方库可以帮助开发者完成 OpenGL 环境的创建以及接口函数的提取，
它们往往本身只提供少量几个额外的专有接口用于初始化等操作，
且这些第三方库本身也是跨平台且开源的，
因此可移植性不会受到影响，可以放心使用。
OpenGL 支持多种常见的编程语言，如：C，C++，Python，Java，等。
本章内容只介绍其在 C/C++ 环境中的使用方法，其他语言的接口定义与 C/C++ 版本基本一致，
如有需要可以非常方便地进行迁移。

本章接下来的教程将使用 GLFW 和 GLAD 这两个第三方库作为样例。
这两个库到本书修订时维护状态较好，故推荐优先选择。
其中 GLFW 负责窗口及环境创建，GLAD 负责提取 OpenGL 接口函数。
其他具有相同功能的库，如：GLUT，GLEW，等，使用方法大同小异，故不再一一介绍。

\subsubsection{Windows 环境搭建}

\label{sec-gl:build-windows-env}

在 Windows 系统上的 OpenGL 环境搭建推荐选择 Visual Studio IDE，
本段将以 Visual Studio 2022 Community 为平台演示基于 GLFW 和 GLAD 的 OpenGL 开发环境搭建流程。

1. 获取 GLFW

前往 \href{https://www.glfw.org/}{GLFW 官方网站 （https://www.glfw.org/）}，
从网站主页顶部导航栏进入 “Download（下载）” 页面，
找到 “Windows pre-compiled binaries（Windows 预编译二进制文件）” 部分，
下载你所要编译的程序的位数（注意，不是操作系统位数，而是你要生成的应用程序位数）的版本的文件。
现代的操作系统和应用程序一般都已升级到 64 位，故此处以 64 位版本为例，
点击 “64-bit Windows binaries（64位 Windows 二进制文件）” 按钮，
即可下载得到一个包含 GLFW 最新版本头文件，及支持各种 Windows 平台编译工具链的链接库文件的压缩包。
将该压缩包解压后先保存在一个位置，以方便之后使用。


\begin{figure}[htbp]
    \centering
    \includegraphics[width = 0.5\linewidth]{imgs/sec 2.2/glfw-download-page.png}
    \centering
    \caption{本书修订时 GLFW 下载页面布局}
    \label{fig-gl:glfw-download-page}
\end{figure}


2. 获取 GLAD

前往 \href{https://glad.dav1d.de/}{GLAD 官方网站（https://glad.dav1d.de/）}，
可以看到一个配置页面，这个页面是配置用来生成适用于不同平台的 GLAD 库文件信息的。
对于个人计算机开发环境，我们只需要将 “API-gl” 一栏选择为 “Version 4.6（本书修订时的最新版本）”，
Profile 一栏选择为 “Core”，如图 \ref{fig-gl:glad-generate-settings} 所示，其他选项保留默认设置，然后点击右下角的 “GENERATE” 按钮，
即可获得合适的 GLAD 版本（本书修订时，点击 “GENERATE” 按钮后，页面会跳转到一个资源列表页面，下载其中的压缩包即可）。
下载到的 GLAD 库包含一个 include/ 文件夹和一个 src/ 文件夹，
分别存放有调用 GLAD 所需要的头文件以及对应的源码。
GLAD 不需要任何形式的链接库，只需要在引用其头文件后，
将其源码加入项目工程即可使用。

\begin{figure}[htbp]
    \centering
    \includegraphics[width = 0.7\linewidth]{imgs/sec 2.2/glad-generate-settings.png}
    \centering
    \caption{GLAD 生成配置（以本书修订时的情况为参考）}
    \label{fig-gl:glad-generate-settings}
\end{figure}

3. 创建 Visual Studio 项目

在进行这一步之前，请先确定系统中已经安装好 Visual Studio， C++ 语言支持，以及 “Windows SDK”，
因为最新版本的 Visual Studio 可以动态配置支持的语言以及拓展工具，
如没有安装 C++ 语言支持，或没有安装 “Windows SDK”，则后续步骤可能无法正常进行。

以 Visual Studio 2022 Community 版本为例。
在准备好以上内容后，进行以下步骤：

- 打开 Visual Studio

- 选择 “创建新项目”

- 选择 “Windows 桌面向导”

- 为项目起一个名称，并选择保存位置，点击 “创建”

- 选择 “控制台应用程序”，并勾选 “空项目”，点击 “确定” 完成项目创建

在项目创建完成后，Visual Studio 会自动打开新创建的项目。
此时，在 “解决方案资源管理器” 中可以看到整个项目的组织结构。
右键点击其中的 “源文件”，依次点击 “添加”-“新建项”；
在弹出的窗口中选择 “C++文件(.cpp)”，
编辑文件名称（如 “main.cpp”），并点击右下角的 “添加”，
即可为新创建的空项目添加一个空的源文件。

在这个新创建的源文件中，可以尝试编写一个 “Hello, World” 程序，按 F5 编译运行，以测试基础环境是否配置正确。

Visual Studio 的功能非常强大，可以配置的选项十分繁复，此处特别提醒：在顶部导航栏可以选择生成应用程序的模式。
Visual Studio 2022 默认为 “Debug-x64”，其中 “Debug” 表示以调试模式编译，
“x64” 表示生成 64 位应用程序。“Debug” 模式默认不开启任何优化，
因此生成的程序运行速度非常慢，如果希望编译高效率的程序，可以将此选项改为 “Release”。
注意，更早版本的 Visual Studio 可能默认目标平台为 “x86”，即 32 位应用程序，
需要手动修改为 “x64” 以适配教程中默认采用的 64 位链接库。

4. 将 OpenGL 库添加到项目中

在进行这一步之前，建议将下载好的 GLFW 和 GLAD 文件移动到项目文件夹中，
以确保项目在迁移到其他设备上时可以正常工作。

为了在编译应用程序时，编译工具能够正确地找到两个第三方库的相关文件，
需要向 Visual Studio 项目添加第三方库的头文件包含目录以及库目录信息，
并将需要用到的静态链接库添加到链接器的配置中。

具体的操作方法为：

在 Visual Studio 窗口顶部导航栏中选择 “项目”-“XXX 属性”（XXX 替换为你的项目名称），
弹出项目属性页。

在属性页顶部首先选择好对应的生成配置，
然后在左侧配置属性中选择 “VC++目录”，
在右侧找到 “包含目录” ，将 GLFW 和 GLAD 文件包中 include/ 目录的路径添加到该项的值中。
再在右侧找到 “库目录” ，将 GLFW 文件包中对应编译工具版本的目录路径添加到该项的值中，
例如，Visual Studio 2022 应选择 “your-glfw-path/lib-vc2022”。

在目录配置完成后，在左侧配置属性中选择 “链接器”-“输入”，
在右侧找到 “附加依赖项”，将 “glfw3.lib” 添加到该项。

最后，保存修改的信息并关闭项目属性页，回到 “解决方案资源管理器”，
右键“源文件”-“添加”-“现有项”，找到 GLAD 文件包中的 src/ 目录，
将其中的 glad.c 文件添加到项目中。

至此，Windows 平台上的 OpenGL 环境配置完毕。
请跳转到 \ref{sec-gl:creating-opengl-window} 节继续阅读。

\subsubsection{Linux 环境搭建}

本节以 Ubuntu-20.04 版本为例，演示在 Linux 平台上的 OpenGL 环境搭建方法。
用于其他 Linux 发行版的方法
可以参考其中共同的部分，
并将和 Ubuntu 系统软件包管理相关的操作替换成对应系统的软件包管理操作。
在搭建 Linux 平台环境之前，请确保所使用的 Linux 平台包含有窗口服务，
否则程序无法正常运行。
一般桌面端的 Linux 发行版都满足此条件，
而服务器端则可能不支持。

1. 获取 GLFW

不同于 Windows 平台，由于 Linux 平台不同发行版之间存在或多或少的差异，
很难提供一套统一的预编译二进制文件。
故，在 Linux 平台上使用 GLFW 库需要通过其开源代码自行编译静态链接库文件。

首先，与 Windows 平台相同，
前往\href{https://www.glfw.org/}{GLFW 官方网站 （https://www.glfw.org/）}
的下载页下载所需的文件。
点击 “Source package（源代码包）” 按钮，获得 GLFW 源代码的压缩包并解压。
进入解压后的文件目录，可以看到一个 CMake 工程的文件结构。

在 GLFW 目录下运行以下指令，以编译安装 GLFW 库文件到系统库目录。

\begin{lstlisting}[language=bash]
sudo apt update
sudo apt install g++ cmake xorg-dev libglu1-mesa-dev
mkdir build
cd build
cmake ..
make
sudo make install
\end{lstlisting}

如未能成功运行以上指令，
可能是系统所使用的软件包管理器不同，
或是缺少一些未被上述指令考虑在内的依赖包，
亦或是权限问题，可以根据问题提示自行搜索解决方案。

2. 获取 GLAD

获取 GLAD 库文件包的方法与 Windows 平台相同，请参考 \ref{sec-gl:build-windows-env} 节对应部分内容。

3. 创建项目代码

在上述操作完成后，在一个合适的位置创建一个项目目录，以下将使用 “project-path/” 代表项目目录。
在创建项目目录后，在项目目录中创建 include/ 目录， makefile 文件及源文件 main.cpp。
然后，将 GLFW 和 GLAD 文件包中的 include/ 目录下的内容复制到 project-path/include/ 目录下；
同时，将 GLAD 文件包中 src/目录下的 glad.c 文件复制到 project-path/ 目录。

此时，项目目录下的文件结构应该如下所示：

\begin{lstlisting}
project-path
├── glad.c
├── include
│   ├── glad
│   │   └── glad.h
│   ├── GLFW
│   │   ├── glfw3.h
│   │   └── glfw3native.h
│   └── KHR
│       └── khrplatform.h
├── main.cpp
└── makefile
\end{lstlisting}

最后，编辑 makefile 文件，写入如下内容

\begin{lstlisting}[language=make]
main: main.cpp glad.c
    g++ main.cpp glad.c -Iinclude -o main -m64 -lglfw3 -lX11 -ldl -pthread
\end{lstlisting}

完成后，即可通过在项目目录下运行如下指令进行程序的编译和运行。

\begin{lstlisting}[language=bash]
make
./main
\end{lstlisting}

\subsubsection{创建 OpenGL 窗口}

在配置好开发环境后，将源文件编写为如下内容，然后编译运行。

\begin{lstlisting}[language=c++]
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <iostream>

int main(void)
{
    GLFWwindow* window;

    /* 初始化 GLFW 库 */
    if (!glfwInit())
        return -1;

    /* 创建窗口 */
    window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* 将窗口设置为当前上下文 */
    glfwMakeContextCurrent(window);

    /* 初始化 GLAD 库，在这一步之后才能调用 glXXX 函数 */
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        glfwTerminate();
        return -1;
    }

    /* 显示设备信息以及 GL 版本 */
    std::cout << "GPU:         " << glGetString(GL_RENDERER) << std::endl;
    std::cout << "GPU Vendor:  " << glGetString(GL_VENDOR) << std::endl;
    std::cout << "GL Version:  " << glGetString(GL_VERSION) << std::endl;

    /* 消息循环 */
    while (!glfwWindowShouldClose(window))
    {
        /* 在这里实现渲染代码 */
        glClearColor(0.6, 0.7, 0.8, 1.0);
        glClear(GL_COLOR_BUFFER_BIT);

        /* 交换缓冲 */
        glfwSwapBuffers(window);

        /* 处理窗口消息 */
        glfwPollEvents();
    }

    glfwTerminate();
    return 0;
}
\end{lstlisting}

如果所有配置都没有错误，即可看到一个 $640\times 480$ 的窗口，如图\ref{fig-gl:hello-window}所示。
同时，控制台会显示出使用的 GPU 设备型号，制造商，以及支持的 OpenGL 版本信息。
如下所示：

\begin{figure}[htbp]
    \centering
    \includegraphics[width = 0.5\linewidth]{imgs/sec 2.4/hello-window.png}
    \caption{代码正常运行时应当显示的窗口}
    \label{fig-gl:hello-window}
\end{figure}

\begin{lstlisting}
GPU:         NVIDIA GeForce RTX 3090/PCIe/SSE2
GPU Vendor:  NVIDIA Corporation
GL Version:  4.6.0 NVIDIA 497.29
\end{lstlisting}

以此为例：
第一行显示使用的显卡名称；
第二行显示显卡厂商；
第三行显示 OpenGL 版本，第一个版本号表示 OpenGL 接口支持的版本，
第二个版本号表示显卡驱动的版本。

如果 OpenGL 未能运行在正确的设备上，
比如：对于同时具有集成显卡和独立显卡的系统，OpenGL 选择了低性能的集成显卡。
则可能需要在操作系统中手动设置图形硬件优先级。
如果发现支持的 OpenGL 版本过低，可能是驱动程序过于老旧，
此时应该及时更新最新的驱动程序。
如更新驱动程序后问题依旧不能解决，
则可能是显卡设备本身过于老旧，无法支持新版本的接口，
但一般不会发生此类情况。

\label{sec-gl:creating-opengl-window}

如果到此处所有功能运行正常，则可顺利进入图形绘制部分代码的编写。

\subsection{绘制三角形}

现代图形 API 普遍以三角形为基本元素进行绘制。
一般来说，在成功创建窗口后，
接下来要做的就是绘制一个三角形，
由此打开通往高性能图形应用开发的大门。
因此 “Hello, Triangle” 就相当于图形领域的 “Hello，World”，
成为了使用任何图形接口进行开发的第一课。

\subsubsection{顶点缓冲}

\label{sec-gl:vertex-buffer}

想要绘制一个三角形，
首先需要定义出这个三角形的样子。
而定义一个三角形最简单的方法就是给出其三个顶点的位置。
在二维空间中，三角形的一个顶点可以用一个二元组表示，
在三维空间中，三角形的一个顶点可以用一个三元组表示；
但这不是顶点在现代化的图形 API 中真正的表示方法。
现代图形 API 普遍用一个四元组表示一个三维坐标，
这种表示法被称作 “齐次坐标”，
额外的那个维度可以理解为坐标的 “缩放反比”。
例如，一个四元组 $(x,y,z,w)$ 所表示的三维坐标为
$(\frac{x}{w},\frac{y}{w},\frac{z}{w})$。
一般情况下，$w=1$；而当 $w=0$ 时，该四元组表示 $(x,y,z)$ 向量。
这种表示法可以带来诸多好处，这部分内容将在 \ref{sec-gl:projection-matrix} 小节详细展开。

除了顶点的位置信息之外，一个顶点可能还会包括颜色，法向量，纹理坐标等服务于渲染的其他信息。
为了简化绘制复杂性，目前阶段对于一个顶点只考虑其位置和颜色信息。
这两个信息分别可由一个四元组表示，位置信息为齐次坐标 $(x,y,z,w)$，
而颜色信息为三通道颜色加上 alpha 通道 $(r,g,b,a)$。
于是，可以用如下方式定义一个三角形的三个顶点的数据：

\begin{lstlisting}[language=c++]
float vertex_buffer[3][8] = {
    { 0.0f,  0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f},
    { 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f},
    {-0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f},
};
\end{lstlisting}

其中每一个八元组的前四个元素表示 $(x,y,z,w)$，后四个元素表示 $(r,g,b,a)$。
对于在二维平面上绘制的情况，坐标的第三维度暂时没有意义，故置为 $0$；
alpha 通道默认为 $1$。

定义好三角形的顶点数据后，需要将这些定点信息传入 GPU 用于绘制。
但 CPU 与 GPU 之间的通信是一个开销非常大的操作，
为了提高应用程序的执行效率，
需要尽可能减少 CPU 与 GPU 之间的通信次数。
因此，为了避免每一帧的绘制都需要将绘制过程的资源从 CPU 端传到 GPU 端，
现代化的图形渲染接口都会提供 GPU 端的缓冲区机制。
缓冲区本质是显存中的一块区域，可以像内存一样存取数据。
不同点是，显存对于 GPU 访问响应速度非常快，对于 CPU 访问响应速度非常慢，而内存反之。
缓冲本身仅用于保存数据，而不关心数据本身的含义，
只有将其绑定到渲染流水线的不同部分时，缓冲才会被赋予不同的意义。
在绘制三角形时，需要先将三角形的顶点信息存入一个缓冲区，
以供渲染流水线调用，这种缓冲区被称作顶点缓冲。

在现代 OpenGL 中，缓冲区需要由程序员手动创建，
赋值。这些操作需要用到如下函数：

\begin{lstlisting}[language=c++]
void glCreateBuffers( GLsizei n, GLuint * buffers );

void glNamedBufferData(
    GLuint buffer,
    GLsizei size,
    const void *data,
    GLenum usage
    );

void glNamedBufferSubData(
    GLuint buffer,
    GLintptr offset,
    GLsizei size,
    const void *data
    );
\end{lstlisting}

glCreateBuffers 用于创建缓冲区对象，并返回创建所对象的标识符。

OpenGL 的对象管理机制并非通过接口类实现，
而是通过标识符实现。
所谓标识符，即一个无符号 32 位整数。
需要对某一对象进行操作时，在调用函数时传入对应的标识符即可表明所操作的对象是哪一个。
因此，在创建某一种对象时，需要调用对应的 glCreate***s 函数获取对应的标识符。
这类函数的调用方法几乎一致，
函数参数为一个整数 $n$ 和一个指向接受标识符的地址空间的指针 $buffers$。
函数会在 $buffers$ 指向的地址空间的前 $n$ 个位置写入 $n$ 个不同的标识符，
指向新创建的 $n$ 个对象。

在只创建一个标识符时，可以这样调用：

\begin{lstlisting}[language=c++]
uint32_t vertex_buffer_object;
glCreateBuffers( 1, &vertex_buffer_object );
\end{lstlisting}

在创建多个标识符时，以 5 个为例，可以这样调用：

\begin{lstlisting}[language=c++]
uint32_t vertex_buffer_objects[5];
glCreateBuffers( 5, vertex_buffer_objects );
\end{lstlisting}

注意，在 OpenGL 函数定义中有许多以 GL 开头的类型，
这是 OpenGL 为了避免在不同平台上原生类型数据长度不统一而设计的。
为了更好地兼容与其他编程库并用时的类型统一性，
建议使用 C/C++ 标准的定长类型替代 GL 类型。
表 \ref{tab-gl:opengl-type} 是一个常用类型之间的简要对照表。

\begin{table}[htbp]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        OpenGL 类型 & 类型实质 & 标准类型\\
        \hline
        GLint & 32 位整型 & int32\_t\\
        \hline
        GLuint & 32 位无符号整型 & uint32\_t\\
        \hline
        GLint64 & 64 位整型 & int64\_t\\
        \hline
        GLuint64 & 64 位无符号整型 & uint64\_t\\
        \hline
        GLbyte & 8 位整型 & int8\_t\\
        \hline
        GLubyte & 8 位无符号整型 & uint8\_t\\
        \hline
        GLenum & 32 位无符号整型 & uint32\_t\\
        \hline
        GLsizei & 32 位整型 & int32\_t\\
        \hline
        GL*ptr & 64 位整型 & int64\_t\\
        \hline
        GLchar & 8 位整型（字符） & int8\_t (char)\\
        \hline
        GLboolean & 8 位无符号整型 & uint8\_t\\
        \hline
        GLfloat & 32 位浮点数（单精度浮点数） & float\\
        \hline
        GLdouble & 64 位浮点数（双精度浮点数） & double\\
        \hline
    \end{tabular}
    \caption{OpenGL 类型对照表}
    \label{tab-gl:opengl-type}
\end{table}

在创建缓冲区对象后，需要使用 glNamedBufferData 函数对新的缓冲区对象创建对应的缓冲区。
函数参数 buffer 表示需要进行创建缓冲区操作的缓冲对象的标识符；
size 表示所要创建的缓冲区的长度，以字节为单位；
data 表示指向用于初始化缓冲区数据的指针，置为 nullptr 则表示不初始化缓冲区的数据；
usage 表示该缓冲区的使用方式特征，需要传入 OpenGL 标准定义的宏。

若想创建一个用于绘制三角形的顶点缓冲区，可以这样调用：

\begin{lstlisting}
glNamedBufferData(
    vertex_buffer_object,
    sizeof(vertex_buffer),
    nullptr,
    GL_STATIC_DRAW);
\end{lstlisting}

其他参数在之前的内容中出现过，不再一一解释。
函数的最后一个参数 GL\_STATIC\_DRAW 表示该缓冲区的数据不会经常被 CPU 写入，
会被经常用于 GPU 端的绘制操作。

这个位置的参数可以看做由两部分组成，首先是表示被访问频率的第一部分，取值有：

1. STATIC；表示很少被 CPU 修改，但会频繁地被 GPU 使用。

2. DYNAMIC；表示经常被 CPU 修改，也会频繁地被 GPU 使用。

3. STREAM；表示很少被 CPU 修改，也只会被 GPU 使用有限的几次，在图形应用中很少会用到。

其次是表示 GPU 端使用方式的第二部分，取值有：

1. DRAW；表示被 CPU 修改，用于 GPU 端的绘制。

2. COPY；表示会被 GPU 端修改，用于 GPU 端的绘制，在图形应用中很少会用到。

3. READ；表示会被 GPU 端修改，用于向 CPU 返回数据，在图形应用中很少会用到。

在常见的 OpenGL 使用情形中，一般将不会每一帧都变换的资源设置为 GL\_STATIC\_DRAW，
将每一帧都很可能发生变化的资源设置为 GL\_DYNAMIC\_DRAW。
此外，这个参数仅表示所创建的缓冲区的使用特征的提示信息，
硬件驱动可能会根据这个参数对数据处理流程做一些优化，
但这个参数不会影响创建出的缓冲区的功能性，仅可能影响缓冲区在执行不同操作时的效率。

在创建好缓冲区后，需要调用 glNamedBufferSubData 函数将 CPU 端的数据上传到缓冲区。
初次上传可以在调用 glNamedBufferData 时完成，但后续的更改需要依赖这个函数。调用方法如下：

\begin{lstlisting}[language=c++]
glNamedBufferSubData(
    vertex_buffer_object,
    0,
    sizeof(vertex_buffer),
    vertex_buffer);
\end{lstlisting}

其中，0 表示缓冲区目标上传位置的偏移量，
sizeof(vertex\_buffer) 表示上传数据的长度，
vertex\_buffer 为 CPU 端数据的起始位置指针。
所示函数调用语句表示把所有顶点数据全部复制到缓冲区中。

如想验证数据是否成功地被复制到缓冲区中，
可以通过 glGetNamedBufferSubData 函数将数据从缓冲区中取回。
调用方法如下：

\begin{lstlisting}
float vertex_buffer_copy[3][8];
glGetNamedBufferSubData(
    vertex_buffer_object,
    0,
    sizeof(vertex_buffer_copy),
    vertex_buffer_copy);
\end{lstlisting}

glGetNamedBufferSubData 函数的参数含义与 glNamedBufferSubData 的基本一致，
区别在于数据流向相反。所示代码将缓冲区中数据复制到了与 CPU 端原数据无关的区域
vertex\_buffer\_copy。
可以通过简单的输入输出手段查看 vertex\_buffer\_copy 中的数据与 vertex\_buffer
是否相同验证数据拷贝是否成功。

本小节着重介绍了三个和缓冲对象相关的 OpenGL 函数，
但 OpenGL 的函数十分繁多，无法在书中一一讲解。
想要了解更多 OpenGL 函数及使用方法，
可以前往 \href{https://docs.gl/}{https://docs.gl/} 进行查询，
这个网站收纳了所有 OpenGL 函数的信息，
包括函数定义，功能，特性，以及支持的版本号等，十分详尽。
后续章节中涉及到的 OpenGL 函数可能不会一一展示函数声明及定义，
如有疑问可以前往该网站进行查询。
（该网站有时在国内访问速度较慢，可以尝试使用网络辅助工具加快访问速度，
在使用网络辅助工具时，请注意遵守相关法律）

更多文档及学习资源请参考 \ref{sec-gl:study-resources} 节。

\subsubsection{着色器}

现代图形渲染接口最显著的特征是对可编程渲染管线的支持。
在以前，绘制复杂的三维场景时只能通过给定的函数接口实现有限的几种渲染效果，
对像素着色的方式也是固定在硬件中的。
这种固定渲染管线的设计虽然可以简化绘制图形的流程，
但难以实现理想的绘制效果。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\linewidth]{imgs/sec 3.2/programmable-rendering-pipeline.png}
    \caption{简化的可编程渲染管线示意图}
    \label{fig-gl:programmable-rendering-pipeline}
\end{figure}

可编程渲染管线的发明极大地拓展了图形硬件的功能，
这种渲染管线的大致流程如图 \ref{fig-gl:programmable-rendering-pipeline} 所示。
图中的流程并非其全貌，而是提取了其中最重要的部分进行示意。
其中用方形框出的阶段是相对固定的，而用椭圆框出的阶段则是可编程的。

现在，由上一小节的内容已经可以得到原始输入的顶点数据，
想要将三角形绘制到屏幕上，需要将原始的顶点数据，
主要是位置坐标，变换到和屏幕对应的二维坐标系上。
否则，硬件设备无法得知该以怎样的方式在屏幕上绘制图形。
这一工作需要由顶点着色器完成。

所谓着色器，即是一些简单的程序块，
类似于常见编程语言中的函数，
只不过这些函数是运行在 GPU，而非 CPU 上的。
这些程序块往往都非常简单，
不会涉及复杂的流程控制，
因而编写起来也十分容易。
比如：顶点着色器最常见的功能就是将原始顶点信息中的三维坐标信息变换成可以直接直接用于绘制的二维坐标；
这一过程的实现会在 \ref{sec-gl:rendering-cube} 节进行详细说明。
对于目前阶段所要绘制的三角形而言，
由于原始的顶点数据中的坐标已经是二维坐标，
所以这一阶段的顶点着色器只需要将顶点坐标信息原封不动地复制到下一阶段即可。

在 OpenGL 中编写着色器需要用到一种十分类似于 C 语言的着色器语言：
OpenGL 着色器语言（OpenGL Shading Language），简称 GLSL。
使用 GLSL 编写一个实现上述功能的顶点着色器的代码如下：

\begin{lstlisting}
#version 450 core
layout (location = 0) in vec4 vs_pos;
layout (location = 1) in vec4 vs_color;
out vec4 fs_color;
void main()
{
    gl_Position = vs_pos;
    fs_color = vs_color;
}
\end{lstlisting}

代码中的第一行用于声明该着色器所使用的 OpenGL 特性版本，
代码中的 450 即表示 4.5.0 版本。
在不需要用到高版本 OpenGL 特性时，
这个版本声明可以写得小一些，以兼容更多不支持高版本 OpenGL 的设备。
但由于现代图形设备普遍都已支持高版本的 OpenGL，
且 OpenGL 几乎已经停止更新了，
此处将版本信息固定写为 450 也不会产生太多问题。

接下来两行代码用于声明顶点着色器的输入：

layout (location = x) 表示变量对应的数据位置编号，
这一设置与即将在 \ref{sec-gl:fixing-pipeline} 小节介绍的管线配置有关，
现在需要了解的是，顶点的位置信息将被分配到 0 号位置，
顶点的颜色信息将被分配到 1 号位置即可。

in 关键字用于表明接下来定义的是一个输入变量。

vec4 表示变量是一个 4 维向量，
GLSL 中默认所有向量和矩阵的基本元素是单精度浮点数，即 float 类型。
如果希望声明整形向量，可以用 vec4i 这种在变量类型名后添加后缀 i 的方式声明。

vs\_pos 和 vs\_color 为变量名，无需多解释。vs 是顶点着色器的英文名称，Vertex Shader，的缩写。

代码第四行表示着色器的输出，
由于顶点着色器的输出直接对应后续片段着色器的输入（虽然中间隔有一个光栅化阶段），
故只需要保证变量名在两个着色器的代码中一致，即可完成对应，故无需再声明 location 字段。
fs 是片段着色器的英文名称，Fragment Shader，的缩写。

接下来是代码的主体函数，
void main() 为所有用 GLSL 编写的着色器的入口，
形式上与 C 语言极为相似。
在这个着色器中，只实现了两个操作，
即：把顶点的坐标 vs\_pos 信息赋予 OpenGL 内置的用于接收变换后的顶点位置信息的特殊变量 gl\_Position；
以及把顶点的颜色信息原封不动的传给下一阶段的片段着色器。

现在已经有了一个简单的顶点着色器。
数据在经过顶点着色器后会进入光栅化阶段，
光栅化的算法在本书之前的章节已经进行过详细的介绍，
在 GPU 中，存在一种固定的光栅化单元用于高效地完成此部分工作。
经过光栅化后，顶点信息会变为许多片段信息。
一个片段可以简单地理解为一个像素，只不过在一些高级的技术中，可能会有多个片段对应一个像素的情况。
片段在经过处理后最终将变为一个颜色值，用于组成最终的画面。
只不过在刚经过光栅化阶段时，片段还会保留了许多原始数据的信息，
需要通过片段着色器对其进行处理，生成最终的颜色信息。

对于目前渲染一个三角形这个任务而言，片段着色器只需要把从顶点着色器继承的颜色信息赋值到输出端即可，
代码如下：

\begin{lstlisting}
#version 450 core
in vec4 fs_color;
out vec4 color;
void main()
{
    color = fs_color;
}
\end{lstlisting}

这段代码没有涉及新的语法内容，不再展开解释。
需要记住的是，片段着色器的输出只能是 vec4 类型的变量，
表示一个 $(r,g,b,a)$ 四通道颜色信息。
每一维度的范围都是单精度浮点数区间 $[0, 1]$，而非常见 24 位位图的整数区间 $[0,255]$，
后续处理流程会自动完成颜色值区间映射过程。

现在所需的着色器代码都已经备齐了，
接下来需要在 C/C++ 代码中编写创建，编译着色器的代码。
以下代码实现了从文件中读取着色器代码，并编译生成 OpenGL 着色器对象的功能：

\begin{lstlisting}[language=c++]
uint32_t CompileGLSLShaderFromFile(
    const char* shader_file_path,
    uint32_t shader_type
)
{
    FILE* file = nullptr;
#ifdef _WIN32
    fopen_s(&file, shader_file_path, "rb");
#else
    file = fopen(shader_file_path, "rb");
#endif
    if (!file) return 0;
    fseek(file, 0, SEEK_END);
    int64_t length = ftell(file);
    char* source_code = new char[length + 1];
    memset(source_code, 0, length + 1);
    fseek(file, 0, SEEK_SET);
    fread(source_code, 1, length, file);
    fclose(file);

    uint32_t shader_object = glCreateShader(shader_type);
    glShaderSource(shader_object, 1, &source_code, nullptr);
    delete[] source_code;
    glCompileShader(shader_object);

    int32_t compilation_success;
    glGetShaderiv(shader_object, GL_COMPILE_STATUS, &compilation_success);
    if (!compilation_success)
    {
        int32_t log_length;
        glGetShaderiv(shader_object, GL_INFO_LOG_LENGTH, &log_length);
        char* error_info = new char[log_length + 1];
        glGetShaderInfoLog(
            shader_object,
            log_length + 1,
            &log_length,
            error_info);
        std::cout << error_info << std::endl;
        glDeleteShader(shader_object);
        delete [] error_info;
        return 0;
    }

    return shader_object;
}
\end{lstlisting}

这个函数的两个参数中，shader\_file\_path 表示着色器代码保存的位置，
shader\_type 则用于标明着色器类型。
如果是顶点着色器，应传入 GL\_VERTEX\_SHADER；
如果是片段着色器，应传入 GL\_FRAGMENT\_SHADER。

函数代码前半部分负责从指定的文件路径读取着色器代码信息。
涉及到的 OpenGL 函数中，glCreateShader 用于创建 OpenGL 着色器对象，
glShaderSource 用于将着色器代码绑定到着色器对象，
glCompileShader 用于编译着色器对象。
在编译完毕后，如果一切正常，
则着色器创建工作完毕，返回着色器对象的标识符即可。
如果着色器写错了，或者声明的着色器类型错误，
则会导致编译失败。
此时，后续的错误处理代码会将编译错误信息提取出来，输出到控制台，并返回 0。

在样例代码中，上文所示的顶点着色器代码和像素着色器代码被分别保存在项目目录下的
 vertex\_shader.glsl 和 fragment\_shader.glsl 文件中。
调用上述函数生成着色器对象的代码如下：

\begin{lstlisting}[language=c++]
uint32_t vertex_shader_object =
    CompileGLSLShaderFromFile("vertex_shader.glsl", GL_VERTEX_SHADER);
uint32_t fragment_shader_object =
    CompileGLSLShaderFromFile("fragment_shader.glsl", GL_FRAGMENT_SHADER);
\end{lstlisting}

如果编译错误，比如在着色器代码中将变量名写错，
编译运行程序后则会出现如下错误提示（错误提示可能因 GPU 生产商的不同或驱动不同产生差异）：

\begin{lstlisting}
0(7) : error C1503: undefined variable "gl_Pos"
\end{lstlisting}

此处错误原因是，误把内置变量 gl\_Position 写成 gl\_Pos。

在着色器编译完成后，
还需要将不同阶段的着色器（Shader）链接成一个着色器程序（Program），
才能在流水线中使用。代码如下：

\begin{lstlisting}
uint32_t LinkProgram(uint32_t vs_object, uint32_t fs_object)
{
    uint32_t program_object = glCreateProgram();
    glAttachShader(program_object, vs_object);
    glAttachShader(program_object, fs_object);
    glLinkProgram(program_object);
    int32_t link_success;
    glGetProgramiv(program_object, GL_LINK_STATUS, &link_success);
    if (!link_success)
    {
        int32_t log_length;
        glGetProgramiv(program_object, GL_INFO_LOG_LENGTH, &log_length);
        char * error_info = new char [log_length + 1];
        glGetProgramInfoLog(
            program_object,
            log_length + 1,
            &log_length,
            error_info);
        std::cout << error_info << std::endl;
        glDeleteProgram(program_object);
        delete[] error_info;
        return 0;
    }
    return program_object;
}
\end{lstlisting}

这个函数可以接受一个顶点着色器标识符和一个片段着色器标识符，
链接生成一个着色器程序，并自动处理链接错误的情况。
当一切正常时，该函数会返回一个着色器程序的标识符。
否则，输出错误信息并返回 0。该函数的调用方法如下：

\begin{lstlisting}[language=c++]
shader_program_object =
    LinkProgram(vertex_shader_object, fragment_shader_object);
\end{lstlisting}

当出现错误时，比如在顶点着色器中误把输出变量名 fs\_color 写成 ps\_color，会出现如下错误提示：

\begin{lstlisting}
Link info
---------
error: "fs_color" not declared as an output from the previous stage
\end{lstlisting}

在成功链接着色器程序后，如着色器对象不会再被使用，可以将其删除以节约资源。

\begin{lstlisting}
glDeleteShader(vertex_shader_object);
glDeleteShader(fragment_shader_object);
\end{lstlisting}

\subsubsection{配置管线}

\label{sec-gl:fixing-pipeline}

如果以上步骤都已经完成且没有发生错误，
至此所有绘制一个三角形所需的资源都已经备齐了。
接下来需要做的就是将准备好的资源，
包括顶点缓冲和着色器程序，
绑定到渲染流水线上，
并渲染出来。

首先需要设置绘制的“视口（Viewport）”，
即窗口中绘制图形的区域，
以像素为单位进行指定。
本例将把图形绘制到整个窗口中，
故视口区域将被设置为窗口大小。
代码如下：

\begin{lstlisting}
int32_t width, height;
glfwGetWindowSize(window, &width, &height);
glViewport(0, 0, width, height);
\end{lstlisting}

其中 glfwGetWindowSize 用于获取窗口大小，glViewport 用于设置视口。

然后是着色器程序。着色器程序是渲染管线中最重要的部分，
它决定了绘制图形的方式。
调用 glUseProgram 函数将着色器程序对象设置为当前使用的着色器程序。

\begin{lstlisting}
glUseProgram(shader_program_object);
\end{lstlisting}

接下来，使用 glBindBuffer 函数将顶点缓冲区对象绑定到流水线顶点缓冲的绑定点。

\begin{lstlisting}
glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer_object);
\end{lstlisting}

OpenGL 接口标准定义了许多缓冲绑定点，
这个函数可以将缓冲区对象绑定到不同的缓冲绑定点，
代码中的 GL\_ARRAY\_BUFFER 是用于声明顶点缓冲绑定点的宏常量，
除此之外，经常被使用的还有索引缓冲绑定点 GL\_ELEMENT\_ARRAY\_BUFFER。

在顶点缓冲绑定完成后，需要将顶点缓冲中的数据对应到顶点着色器的输入。
这一步可以使用 glVertexAttribPointer 函数完成此项工作。方法如下：

\begin{lstlisting}
glVertexAttribPointer(0, 4, GL_FLOAT, false, 32, (void*)0);
glVertexAttribPointer(1, 4, GL_FLOAT, false, 32, (void*)16);
\end{lstlisting}

以上函数每一项参数对应的含义如图 \ref{fig-gl:vertex-attrib} 所示。

第一个参数 index 对应了顶点着色器中的 layout (location = x) 字段，
用于声明保定数据的位置；

第二个参数 size 对应了着色器输入变量类型含有的元素个数，
如：四维向量 vec4 含有 $4$ 个元素，
$4\times 4$ 的矩阵 mat4 含有 $16$ 个元素。

第三个参数 type 对应了元素类型，此例中为 float 类型，对应 OpenGL 标准宏常量为 GL\_FLOAT。
此外还有 GL\_DOUBLE，GL\_INT, GL\_UNSIGNED\_INT, GL\_BYTE，GL\_UNSIGNED\_BYTE 等参数可选。

第四个参数 normalized 表示是否要对数据进行归一化处理，一般置为 false。

第五个参数 stride 表示从一组数据到下一组数据，起始位置相差多少个字节；
一般使用一个顶点数据的大小。当前一个顶点使用了 8 个 float，总共为 32 字节。

第六个参数 pointer 表示当前位置的数据相对一组数据的起始点的偏移量。
比如位置数据前方没有数据，则为 0；颜色数据在位置数据之后，而位置数据占据 16 个字节，故为 16。
此处参数虽然要求为指针类型，但实际作用方式和整数标量无异。

\begin{figure}[htbp]
\centering
\includegraphics[width=0.8\linewidth]{imgs/sec 3.3/vertex-attrib.png}
\caption{glVertexAttribPointer 函数参数对照关系示意图}
\label{fig-gl:vertex-attrib}
\end{figure}

在绑定好每个位置的顶点数据后，还要将用到的位置激活，调用以下函数实现：

\begin{lstlisting}
glEnableVertexAttribArray(0);
glEnableVertexAttribArray(1);
\end{lstlisting}

注意：存在一个与函数 glEnableVertexAttribArray 名称十分相似的函数 glEnableVertexArrayAttrib，
但功能并不相同，应当避免混淆。

至此，渲染一个三角形所需要进行的管线信息配置已经全部完成，
调用函数 glDrawArrays 即可渲染出三角形。方法如下：

\begin{lstlisting}
glDrawArrays(GL_TRIANGLES, 0, 3);
\end{lstlisting}

函数第一个参数用于指定绘制模式。
GL\_TRIANGLES 表示将顶点按照三个一组的方式组成三角形绘制。
除此之外，还可以尝试以下模式：

\begin{table}[htbp]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        GL\_POINTS&绘制点（可能会很难看清）\\
        \hline
        GL\_LINE\_STRIP&绘制直线带\\
        \hline
        GL\_LINE\_LOOP&绘制直线环\\
        \hline
    \end{tabular}
    \caption{OpenGL 绘制模式对照表}
\end{table}

函数第二个参数表示绘制起始顶点的编号，置为 0 表示从头开始。

函数第三个参数表示总共参与绘制的顶点数量。

如果没有发生问题，此时编译运行程序应该能够看到被绘制出的三角形。如图 \ref{fig-gl:hello-triangle} 所示。

\begin{figure}[htbp]
\centering
\includegraphics[width=0.5\linewidth]{imgs/sec 3.3/hello-triangle.png}
\caption{你好，三角形}
\label{fig-gl:hello-triangle}
\end{figure}

\subsection{绘制立方体}

\label{sec-gl:rendering-cube}

成功绘制出一个三角形，
就已经完成了走向高性能图形绘制最重要的一步。
本章节要达成的目标，是从二次元走向三次元。
更高的维数可以设计更复杂的场景，
带来了更高的“可玩性”，
走向三维也是连接虚拟和现实世界的必经之路。
实现这个目标可谓意义重大。

具体来说，本章节最终将实现利用 OpenGL 绘制一个具有立体感的立方体。
之所以选择立方体，是因为立方体能够比较好地体现三维渲染的特点，
描述一个立方体又相对简单。
故许多图形绘制教程都会选择立方体作为三维图形绘制的例子，
本书也不例外。

\subsubsection{坐标变换}

\label{sec-gl:coordinate-transform}

立方体可以由空间中的 12 个三角形组成，
用上一节中的方法将这 12 个三角形合理地绘制出来，
目标就达成了。
但空间中的三角形使用的是三维顶点坐标，
绘制三角形需要的是和屏幕所在平面相关的二维坐标。
在绘制空间中的三角形之前，
需要先将空间中的三角形对应到屏幕上的三角形。

但这种对应关系并不唯一，它受许多因素影响。
想象一个人围着一个摆在桌子上的三角形转一圈，
然后自身再转一圈，再走远。
这个过程中，
这个人看到的三角形的形状，大小，位置，甚至能否看到三角形这个状态都会随着人的移动发生变化。
这还没有考虑到三角形自身的移动和变化等等问题。
这些问题可以统一地归纳为坐标变换问题。

要考虑坐标变换问题，需要先将问题分为两部分。
一部分是空间坐标到空间坐标的变换。
比如物体的移动，整体拉伸，旋转等。
根据一些简单的线性代数和几何知识可以明白，
物体在空间中发生的移动，整体拉伸，旋转等变化，
都属于放射变换。
而仿射变换又都可以通过线性操作完成，
因此，这部分由空间坐标到空间坐标的变换是容易解决的。
如果遇到特殊的非线性空间坐标变换，
可以具体问题具体分析，无法一概而论。

到此为止，经过一系列空间坐标到空间坐标的变换后，
可以视所有空间坐标为以观察者所处位置及方向所形成的的坐标系中的坐标。
所谓观察者，可以想象成一个相机，或者眼睛，有所处位置及上下左右前后之分，
故可以用一个坐标系表示空间中物体相对于观察者的位置关系，
这个坐标系被称作观察坐标系。

坐标变换的第二部分是从空间坐标到屏幕坐标的变换，是实现三维图形绘制最为精妙的部分。
想象一个拥有变化的视野范围的观察者，
例如一个可调节倍率的望远镜（假设倍率可以从 1.0x 调节到 $\infty$x）。
其观察到的图像也会随着视野的变化而发生变化，
当图像大小一定时，低视野范围的观察者观察到的图形就会显得大。
再想象出一个可以穿墙的观察者从远处开始面朝一堵面积有限的墙移动，
直至穿过这堵墙。
墙会先随着观察者距离的逼近逐渐变大，然后在穿墙的瞬间消失。
再例如，距离近的静止物体在观察者移动时，在观察者的视野中移动速度快，
而远距离的物体在观察者视野中移动速度慢。
通过以上观察不难得出结论，从空间坐标到屏幕坐标的变换具有非线性性，
因此描述这种变换相对困难一些。

描述这种变换需要先对视觉形成的过程进行分析。
首先，观察者所处位置被称为“视点”。
从视点出发，以视野范围为限，
向视野内各个方向发出射线，所形成的锥形区域，称作“视锥”。
在现实世界中，无论是眼睛还是相机镜头，
视觉成像的本质是视锥内的物体在“感光区域”所形成的投影；
这个“感光区域”是在视点后方的，
投影过程还需要一个凸透镜进行聚焦。
但在进行三维图形绘制的坐标变换时，不需要考虑如此复杂。
首先 “感光区域” 可以简化为置于视点前方的一个“窗口”，
视觉成像过程即为物体与视点连线，在这个“窗口”上的投影。
观察方向上的物体会投影到“窗口”的中心位置，
而视野边缘的物体会投影到“窗口”的边缘位置。

有了以上抽象的模型，接下来需要对其进行代数化的表达。
首先，需要通过代数准确描述 “窗口” 的特征，
由于视点到“窗口”的距离可近可远，
但“窗口”的相对形状是固定的，
因此，可以规定窗口的位置与视点的距离为单位距离 $1$，
即“窗口”位于 $z=1$ 的平面上。
由于 “窗口” 形状通常为矩形，且矩形边平行于观察坐标系的坐标轴，
因此，可以用简单的长和宽的长度描述“窗口”的形状和大小，记为 $a$ 和 $b$。
然后，求空间中一点在“窗口”上的投影，
可以转化为先求该点与视点的连线与平面 $z=1$ 的交点，
再判断该交点是否在“窗口”区域内。
由于在观察坐标系中，视点位于坐标系原点 $(0, 0, 0)$，
因此，空间点 $(x, y, z)$ 与原点 $(0, 0, 0)$ 的连线
在平面 $z=1$ 上的交点为 $(x/z, y/z, 1)$。
对于上述“窗口”为矩形的情况，
只需要判断是否满足
$-a/2 \le x/z \le a/2$
且 $-b/2 \le y/z \le b/2$，
即可获知空间点 $(x, y, z)$ 的投影点是否在窗口内。
如果将窗口坐标归一化表示，
令视野内空间点变换得到窗口坐标放缩到 $[-1, 1]\times[-1, 1]$，
则可以将参数 $a, b$ 带入变换，得到投影变换函数 proj：
$$\text{proj}\left(x, y, z\right) = (\frac{2x}{az}, \frac{2y}{bz}, 1)$$


\subsubsection{标准化设备坐标（NDC）空间}

接下来的内容涉及到一个几乎所有现代 3D 图形接口都采用的接口设计标准，
称作标准化设备坐标（Normalized Devicem Coordinate）空间。这个空间就是一个
$[-1, 1]\times [-1, 1] \times [-1, 1]$（OpenGL 默认标准），或者 $[-1, 1]\times [-1, 1] \times [0, 1]$（DirectX 标准）的长方体。
它规定了，只有在这个范围内的点才会被渲染；
超出这个范围的点会被渲染管线自动丢弃，
不会绘制到图像上。

回忆一下在上一节中定义的三角形：

\begin{lstlisting}
float vertex_buffer[3][8] = {
    { 0.0f,  0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f},
    { 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f},
    {-0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f},
};
\end{lstlisting}

这个三角形表示的三个顶点坐标是
$(0.0, 0.5, 0.0)$，
$(0.5, -0.5, 0.0)$，
$(-0.5, -0.5, 0.0)$。

其中，前两个维度线性对应了绘制区域的位置。
绘制区域的最左端和最下端定义为对应维度的 $-1$，
最右端和最上端则定义为对应维度的 $1$。

对于一般的图形绘制接口来说，
前两个维度足够定义一个点在图像中的位置了。
但对于三维图形绘制，简单地把第三维度丢掉会造成信息的损失。
这部分信息决定了物体之间的遮挡关系，对于将图形绘制正确至关重要。
因此，在现代图形绘制接口中，经过变换后的坐标依然保留了三个维度。

这第三个维度通常表示绘制点的“深度”，
即视点到绘制点的距离。
但由于第三维度也被限制在 $[-1, 1]$，
其表示的深度信息往往是经过了一层单调函数的映射的，
这样可以保证大小关系不受影响，
以方便后续的遮挡关系的处理。

为了实际地感受第三维度的作用，
可以将上一节的三角形其中一个顶点的第三维度坐标改为 $-2.0$，
观察运行结果。结果应当显示，原本的三角形变成了一个梯形，如图
\ref{fig-gl:clipped-triangle}
所示。

\begin{figure}[htbp]
\centering
\includegraphics[width=0.5\linewidth]{imgs/sec 4.2/clipped-triangle.png}
\caption{因第三维度超出范围，被剪裁掉一块的三角形}
\label{fig-gl:clipped-triangle}
\end{figure}

\subsubsection{深度缓冲}

在正式绘制三维图形之前，
还需要了解图形接口是如何处理物体之间的遮挡关系的。
上一小节中已经介绍了深度信息的概念，
而遮挡关系的本质就是：
与视点共线的物体，
距离视点近的物体会遮挡住距离视点远的物体。
由于深度信息保持了距离信息的大小关系，
对于绘制到同一像素的不同片段，
只需要对比其深度值的大小，
保留深度值最小的片段进行绘制即可。

由于每个片段都会对应图像上的一个位置，
人们普遍采用深度缓冲技术处理以上基于深度值的比较。
具体过程为：创建一个与绘制目标图像相同大小的单通道图像，称作“深度缓冲”。
深度缓冲可以针对每一个绘制目标的像素额外存储一个深度信息值，
每次绘制前，需要将这个缓冲中的数据都重置为 $1.0$，表示最大的深度值。
每个片段在绘制到目标图像之前，
会将自己的深度信息值先与深度缓冲中对应位置的深度信息值进行对比。
如果该片段的深度值小于当前位置的深度值，
则绘制该片段并更新深度缓冲中的信息，
否则则丢弃该片段。这个过程被称作“深度测试”。

在 OpenGL 中，
用于创建窗口的第三方库一般会自动为窗口创建一个深度缓冲，
但默认状态下不开启深度测试。
需要调用以下函数手动开启深度测试：

\begin{lstlisting}
glEnable(GL_DEPTH_TEST);
\end{lstlisting}

并在每一帧绘制之前调用如下函数重置深度缓冲中的数据：

\begin{lstlisting}
glClear(GL_DEPTH_BUFFER_BIT);
\end{lstlisting}

接下来，用于绘制的三角形数据改为：

\begin{lstlisting}
float vertex_buffer[12][8] = {
    { 0.0f, 0.5f, 0.0f, 1.0f, 0.75f, 0.75f, 0.75f, 1.0f},
    { 0.5f, 0.5f, 0.0f, 1.0f, 0.75f, 0.75f, 0.75f, 1.0f},
    { 0.5f, -0.5f, 1.0f, 1.0f, 0.75f, 0.75f, 0.75f, 1.0f},
    { 0.5f, -0.0f, 0.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f},
    { 0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f},
    {-0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f},
    {-0.0f, -0.5f, 0.0f, 1.0f, 0.25f, 0.25f, 0.25f, 1.0f},
    {-0.5f, -0.5f, 0.0f, 1.0f, 0.25f, 0.25f, 0.25f, 1.0f},
    {-0.5f, 0.5f, 1.0f, 1.0f, 0.25f, 0.25f, 0.25f, 1.0f},
    { -0.5f,  0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f},
    {-0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f},
    { 0.5f, 0.5f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f},
};
\end{lstlisting}

并将绘制函数调用中的绘制顶点数改为 $12$：

\begin{lstlisting}
glDrawArrays(GL_TRIANGLES, 0, 12);
\end{lstlisting}

编译运行程序后，应得到如图 \ref{fig-gl:enable-depth-test} 的结果：

\begin{figure}[htbp]
\centering
\subfigure[开启深度测试]{
    \begin{minipage}[t]{0.4\linewidth}
    \centering
    \includegraphics[height=1.6in]{imgs/sec 4.3/depth-buffer.png}
    \label{fig-gl:enable-depth-test}
    \end{minipage}
}
\subfigure[关闭深度测试]{
    \begin{minipage}[t]{0.4\linewidth}
    \centering
    \includegraphics[height=1.6in]{imgs/sec 4.3/disable-depth-buffer.png}
    \label{fig-gl:disable-depth-test}
    \end{minipage}
}
\caption{深度缓冲样例，可以看到四个三角形互相遮挡。}
\end{figure}

作为对比，可以删除开启深度测试相关代码，
结果如图 \ref{fig-gl:disable-depth-test} 所示。

\subsubsection{投影矩阵}

\label{sec-gl:projection-matrix}

在理解了透视除法、NDC 空间以及深度测试后，
接下来需要用一种方式在顶点着色器中简洁地表达这些过程。
在 \ref{sec-gl:vertex-buffer} 小节中已经提到，
三角形顶点的坐标是以齐次坐标的形式存储的，
一个齐次坐标四元组 $(x, y, z, w)$ 实际表示三维坐标 $(x/w, y/w, z/w)$。
这种表示法中的非线性性刚好与透视除法中，
由三维坐标 $(x, y, z)$ 变换到 $(x/z, y/z, 1)$ 的除法操作相吻合。
因此，假设顶点坐标都是以 $(x, y, z, 1)$ 的格式存储的，
只需要左乘以下矩阵：
$$
\left[    
\begin{matrix}
    1&0&0&0\\
    0&1&0&0\\
    0&0&1&0\\
    0&0&1&0
\end{matrix}
\right]
$$

即可将坐标四元组变换为 $(x, y, z, z)$，这样，
经过齐次坐标归一化后，坐标变为 $(x/z, y/z, 1, 1)$。

这样的矩阵成功完成了从三维到二维的透视投影，
但深度信息并没有保留。
想要保留深度信息，
需要把原坐标中的 $z$ 值映射到 NDC 空间第三维度的区间上。
为了兼容更多的图形接口（如 DirectX），
接下来讨论将 $z$ 值映射到 $[0, 1]$ 的方法。

首先，$z$ 的取值范围是一个 $(-\infty, +\infty)$ 的区间，
如果不加以限制，则映射精度难以保证。
故需要规定只有在 $[near,far]$ 范围内的 $z$ 值才会被映射到 $[0, 1]$ 区间内。
超出范围的 $z$ 值，变换后将超出 NDC 范围，进而被渲染管线丢弃。

第二，因为深度信息要保持原始 $z$ 值的相对大小关系，
映射 $f:\mathbb{R}\mapsto\mathbb{R}$ 应满足
$x<y\mapsto f(x)<f(y)$。

然后，由于变换后其次坐标的前两维度和第四维度是不能轻易改动的，
否则透视除法不容易正常完成，因此，变换矩阵应该是如下形式的：

$$
P=\left[
\begin{matrix}
    1&0&0&0\\
    0&1&0&0\\
    0&0&a&b\\
    0&0&1&0\\
\end{matrix}
\right]
$$

这样得到 $P\left(x, y, z, 1\right)^T=\left(x,y,az+b,z\right)$，
齐次坐标归一化后得到 $\left(x/z, y/z, a+b/z, 1\right)$。
由于映射函数 $p(z)=a+b/z$ 在 $z\in(0,+\infty)$ 时是单调的
（$z$ 值为负的点可以直接丢弃，因为视点后方的物体正常情况下是不可见的）。
因此，只需解出合适的 $a, b$ 取值，即可满足所有对 $z$ 值映射的要求。
前边提到，需要带入一个人为规定的区间 $[near,far]$ 以提高映射精度，
使 $[near, far]$ 能映射到 $[0, 1]$，
只需解出方程组
$$\left\{
    \begin{array}{ll}
        p(near)=a+b/near&=0\\
        p(far)=a+b/far&=1
    \end{array}
\right.$$
即可得到 $$
\left\{
    \begin{array}{ll}
        a&=\frac{far}{far-near}\\
        b&=\frac{near\times far}{near-far}
    \end{array}
\right.$$
最终得到投影矩阵 $P$：
$$
\left[
    \begin{matrix}
        1&0&0&0\\
        0&1&0&0\\
        0&0&\frac{far}{far-near}&\frac{near\times far}{near-far}\\
        0&0&1&0
    \end{matrix}
\right]
$$

根据以上投影矩阵的定义，
只需要将 $near,far$ 带入，
计算出矩阵各个项的值，
然后在顶点着色器中将顶点坐标左乘投影矩阵，
即可完成 OpenGL 中的投影变换。

\subsubsection{uniform 变量}

投影矩阵通常是一个矩阵作用于所有顶点，
如果将矩阵的数据作为顶点数据传入顶点着色器，
会造成许多不必要的空间浪费。

GLSL 提供了描述可以通过 C 语言函数接口修改的全局变量的方法，
即 uniform 变量。

具体定义方式如下：
\begin{lstlisting}
uniform mat4 mat_proj;
\end{lstlisting}
同时需要将给 gl\_Position 赋值的语句改为：
\begin{lstlisting}
gl_Position = mat_proj*vs_pos;
\end{lstlisting}
接下来，只需要将投影矩阵的数据传入 mat\_proj 变量，
即可实现投影变换。

GLSL 中的矩阵是以列优先的方式存储的，
因此，用 C 代码描述一个投影矩阵的方法如下：

\begin{lstlisting}[language=c++]
void ProjectionMatrix(float Near, float Far, float * mat_data)
{
    float data[] = {
        1.0f, 0.0f, 0.0f,                        0.0f,
        0.0f, 1.0f, 0.0f,                        0.0f,
        0.0f, 0.0f, Far / (Far - Near),          1.0f,
        0.0f, 0.0f, (Far * Near) / (Near - Far), 0.0f
    };
    memcpy(mat_data, data, sizeof(data));
}
\end{lstlisting}

注意：near 和 far（全小写字母）是关键字，需要避开。

然后，从着色器程序提取出 uniform 变量 mat\_proj 的位置（作用类似于标识符）：

\begin{lstlisting}
int32_t mat_proj_location
    = glGetUniformLocation(shader_program_object, "mat_proj");
\end{lstlisting}

再将投影矩阵的数据传入着色器程序中的 uniform 变量：

\begin{lstlisting}
/* 声明接收矩阵数据的空间 */
float mat_proj_data[16];
/* 获取矩阵数据 */
ProjectionMatrix(1.0, 10.0, mat_proj_data);
/* 将矩阵数据根据位置标识符传入着色器程序 */
glUniformMatrix4fv(mat_proj_location, 1, false, mat_proj_data);
\end{lstlisting}

glUniformMatrix4fv 的第二个参数用于声明矩阵个数，
主要用于 uniform 数组的情况，
对于单个变量，设置为 $1$ 即可。

glUniformMatrix4fv 的第三个参数用于声明矩阵是否需要转置，
如为 true，则传入的是转置后的矩阵数据。此处应设置为 false。

除此之外，还有许多 glUniform* 格式的函数，
用于传入不同类型的变量，具体信息可以前往 docs.gl 查询。

\subsubsection{索引缓冲}

现在，坐标变换的原理和实现都已解决，
最后需要将需要绘制的正方体定义出来。

不同于上一节中只有一个三角形的情况，
组成正方体的 $12$ 个三角形存在很多共顶点，
如果每一个三角形都把三个顶点的数据复述一遍，
原始的 $8$ 个顶点会变成 $36$ 个顶点，
这样的方式造成了很高比例的资源浪费。

对于这个问题，可以引入索引缓冲区解决。
具体来说，数据的定义方式如下：

\begin{lstlisting}
float vertex_buffer[8][8] = {
    {-1.0f,-1.0f,-1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f},
    {-1.0f,-1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f},
    {-1.0f, 1.0f,-1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f},
    {-1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f},
    { 1.0f,-1.0f,-1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f},
    { 1.0f,-1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f},
    { 1.0f, 1.0f,-1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f},
    { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f},
};

uint32_t index_buffer[36] = {
    0,2,1,
    1,2,3,
    4,5,6,
    5,7,6,
    0,6,2,
    0,4,6,
    1,3,5,
    3,7,5,
    2,6,3,
    3,6,7,
    0,1,4,
    1,5,4
};
\end{lstlisting}

顶点缓冲包含了一个立方体八个顶点的数据，
索引缓冲则以三个为一组，
定义了每个三角形三个顶点对应的顶点编号。
然后，将索引缓冲同样复制到一个缓冲对象中：
\begin{lstlisting}
glCreateBuffers(1, &index_buffer_object);
glNamedBufferData(
    index_buffer_object, 
    sizeof(index_buffer), 
    nullptr, 
    GL_STATIC_DRAW
);
glNamedBufferSubData(
    index_buffer_object,
    0,
    sizeof(index_buffer),
    index_buffer
);
\end{lstlisting}

最后，将索引缓冲对象绑定到流水线，
并将绘制函数由原来的 glDrawArrays 改为索引模式的 glDrawElements：

\begin{lstlisting}
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer_object);
glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, nullptr);
\end{lstlisting}

glDrawElements 的第三个参数用于说明索引数据的类型，
应当与定义时的类型相符。

最后一个参数是用于指定第一个索引在索引缓冲中的位置的，
以字节为单位。

此时，定义的立方体是完全包裹住坐标原点的，
为了看清它需要将其放远一点，比如将所有顶点的 $z$ 轴坐标加 $5$：

\begin{lstlisting} 
for (int i = 0; i < 8; i++)
    vertex_buffer[i][2] += 5.0;
\end{lstlisting}

这样，编译运行后就能看到立方体的正面了，效果如图。

\begin{figure}[htbp]
\centering
\includegraphics[width=0.5\linewidth]{imgs/sec 4.6/hello-cube.png}
\caption{由于立方体是正对着观察者的，因此只能看到一个面。}
\end{figure}

\subsubsection{最终效果}

对于一个三维立方体，只能看到一个面当然是难以让人满意的，
所以需要想办法让它转起来。
为了描述方便，样例中引入了一个简单的自定义矩阵类型，
支持矩阵乘法操作。
这部分代码可以自行实现，
或使用第三方数学库，
故不再在此示出。

为了让物体旋转，
需要额外用一个 uniform 变量接收变换顶点坐标的矩阵，
并在顶点坐标左乘投影矩阵之前先左乘先左乘这个矩阵。

空间坐标变换的矩阵可以同时处理旋转和平移操作，
故不再需要上一小节中手动给所有顶点的 $z$ 坐标加 $5$ 的代码。

定义平移矩阵和旋转矩阵的代码如下：
\begin{lstlisting}
/* 平移矩阵 */
Matrix TranslateMatrix(float x, float y, float z)
{
    return Matrix(
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
            x,   y,   z, 1.0
        );
}
/* 旋转矩阵
   pitch：俯仰角
   yaw：偏航角
   roll：滚转角
 */
Matrix RotationMatrix(float pitch, float yaw, float roll)
{
    return
        Matrix(
                cos(yaw), 0.0, sin(yaw), 0.0,
            0.0,       1.0, 0.0,      0.0,
            -sin(yaw), 0.0, cos(yaw), 0.0,
            0.0,       0.0, 0.0,      1.0
            ) *
        Matrix(
            1.0, 0.0,        0.0,        0.0,
            0.0, cos(pitch), sin(pitch), 0.0,
            0.0,-sin(pitch), cos(pitch), 0.0,
            0.0, 0.0,        0.0,        1.0
            ) *
        Matrix(
            cos(roll),-sin(roll), 0.0, 0.0,
            sin(roll), cos(roll), 0.0, 0.0,
            0.0,       0.0,       1.0, 0.0,
            0.0,       0.0,       0.0, 1.0
            );
}
\end{lstlisting}

通过以上函数，将三个方向的旋转角每一帧都增加一定量，
即可实现旋转效果。

\begin{lstlisting}
pitch += 0.001; yaw += 0.002; roll += 0.003;
Matrix mat_trans
    = TranslateMatrix(0.0, 0.0, 5.0) * RotationMatrix(pitch, yaw, roll);
glUniformMatrix4fv(mat_trans_location, 1, false, (float*)&mat_trans);
\end{lstlisting}

此外，由上一小节的绘制结果可以看出，绘制出的立方体被拉长了。
这是因为窗口的长宽并不相等，但都映射到了 NDC 空间的 $[-1, 1]$ 范围。
为解决这个问题，需要在投影矩阵中引入长宽比修正项（已经改为矩阵类型返回的形式）：

\begin{lstlisting}
/* aspect 即为长宽比修正项 */
Matrix ProjectionMatrix(float Near, float Far, float aspect)
{
    return Matrix(
        1.0f / aspect, 0.0f, 0.0f,                        0.0f,
        0.0f,          1.0f, 0.0f,                        0.0f,
        0.0f,          0.0f, Far / (Far - Near),          1.0f,
        0.0f,          0.0f, (Far * Near) / (Near - Far), 0.0f
    );
}
\end{lstlisting}

调用时需要传入长宽比参数：
\begin{lstlisting}
Matrix mat_proj = 
    ProjectionMatrix(1.0, 10.0, (float)width / (float)height);
glUniformMatrix4fv(mat_proj_location, 1, false, (float*)&mat_proj);
\end{lstlisting}

以上修改完成后，编译运行程序即可看到一个旋转的立方体，
并且没有拉伸变形的问题了。运行效果如图 \ref{fig-gl:rotating-cube} 所示。

\begin{figure}
\centering
\includegraphics[width=0.5\linewidth]{imgs/sec 4.7/rotating-cube.png}
\caption{运行结果中的一帧}
\label{fig-gl:rotating-cube}
\end{figure}

至此，从二维走向三维的跨越成功实现。


\subsection{纹理贴图}

绘制三维世界，仅仅依靠几何模型是不够的，
因为许多现实世界中的很多细节，依靠建模表达会非常浪费资源，
同时效果也不明显。
比如在绘制一面砖墙的时候，
如果用建模的方式绘制一面砖墙，
则每一块墙砖、每一条缝隙都需要用更多的三角形来表示。
为了使绘制的效果更真实，建模所需要的三角形数量规模是巨大的。
这对资源有限的实时渲染场景是极大的压力。

于是纹理贴图技术应运而生，
纹理贴图的本质就是使用一张图片代替许多模型细节，
同样是绘制一面砖墙的案例，
设计师只需要一张砖墙的图片，
并将其绘制到一个矩形上，
就实现了砖墙的效果，简单方便。
而在需要增加细节时，往往只需要提升纹理贴图的分辨率即可。

纹理贴图的应用不只是在几何图形上绘制更多颜色，
它还可以用于提供其它方面的信息，
比如：法向贴图可以用于表示同一平面上法向量的偏移量，
结合光照模型绘制出凹凸感。
这些高级的用法可以自行查找相关资料进行学习，
本节内容仅介绍最简单的纹理贴图使用方法。

\subsubsection{加载纹理}

使用纹理贴图的第一步是将纹理数据加载到 OpenGL 设备中。
将图片从文件加载到内存并进行编码解码的过程并不统一，
这个过程有许多第三方库可以使用，并不是问题的关键，
故在此不进行说明。
为了快速获得一段纹理数据，可以直接在内存中构造一个纹理贴图：
\begin{lstlisting}[language=c++]
uint8_t pixel_data[256][256][3];
for (int i = 0; i < 256; i++)
    for (int j = 0; j < 256; j++)
    {
        pixel_data[i][j][0] = i ^ j;
        pixel_data[i][j][1] = i ^ j;
        pixel_data[i][j][2] = i ^ j;
    }
\end{lstlisting}

构造出的纹理如图\ref{fig-gl:texture}：
\begin{figure}[htbp]
\centering
\includegraphics[width=0.35\linewidth]{imgs/sec 5.1/texture.png}
\caption{构造出的纹理}
\label{fig-gl:texture}
\end{figure}

接下来，需要在 OpenGL 中创建一个纹理对象，
并将数据上传到创建的纹理对象中。
这个过程与创建缓冲对象并上传数据的过程类似，
代码如下：

\begin{lstlisting}
glCreateTextures(GL_TEXTURE_2D, 1, &texture_object);
glBindTexture(GL_TEXTURE_2D, texture_object);
glTexImage2D(
    GL_TEXTURE_2D,
    0,
    GL_RGB32F,
    256, 256,
    0,
    GL_RGB, GL_UNSIGNED_BYTE, pixel_data);
glBindTexture(GL_TEXTURE_2D, 0);
\end{lstlisting}

这段代码中，GL\_TEXTURE\_2D 表示创建的纹理对象是一个二维纹理，
也是最通用的一种纹理。
OpenGL 中操作纹理对象之前必须先将纹理绑定到绑定点上，
再根据绑定点进行操作。
因此需要在使用 glTexImage2D 函数进行数据上传的前后，
通过 glBindTexture 函数进行绑定和解绑，
绑定点同样也用 GL\_TEXTURE\_2D 指定。

以上代码中，glTexImage2D 函数相对比较复杂。其定义如下：

\begin{lstlisting}
void glTexImage2D(
    GLenum target,
    GLint level,
    GLint internalFormat,
    GLsizei width,
    GLsizei height,
    GLint border,
    GLenum format,
    GLenum type,
    const GLvoid * data);
\end{lstlisting}

target：

用于指定纹理对象的绑定点。此处为 GL\_TEXTURE\_2D。

level：

表示纹理的细节层数，在一些高级的技术中会用到。此处置为 0。

internalFormat：

表示纹理对象的内部存储格式。
这里要特别注意，
前文中定义的纹理数据是用三个字节表示一个像素的 RGB 三通道信息的。
但上传数据的格式不必和内部存储格式一致，
OpenGL 会自动进行格式转换操作。
此处样例中设为 GL\_RGB32F，表示内部各式具有 RGB 三通道，
每个通道都用一个 32 位浮点数表示。
一些其它 OpenGL 支持的常用内部格式见表 \ref{tab-gl:internal-format-list}。

一般的图片都是用 8 位无符号归一化整数，
将 $[0, 255]$ 映射到 $[0, 1]$ 表示一个通道的颜色数据。
而浮点数表示的纹理通常用于记录一些其它的数据，
其单通道表示范围也不限于 $[0, 1]$，可以支持完整的浮点数域。

\begin{table}
\begin{tabular}{|l|l|l|l|l|l|l|}
    \hline
    内部格式&R通道&G通道&B通道&A通道&说明\\
    \hline
    GL\_R8&8位&&&&无符号归一化整数\\
    \hline
    GL\_RG8&8位&8位&&&无符号归一化整数\\
    \hline
    GL\_RGB8&8位&8位&8位&&无符号归一化整数（24位色）\\
    \hline
    GL\_RGBA8&8位&8位&8位&8位&无符号归一化整数\\
    \hline
    GL\_R32F&32位&&&&单精度浮点数\\
    \hline
    GL\_RG32F&32位&32位&&&单精度浮点数\\
    \hline
    GL\_RGB32F&32位&32位&32位&&单精度浮点数\\
    \hline
    GL\_RGBA32F&32位&32位&32位&32位&单精度浮点数\\
    \hline
\end{tabular}
\caption{OpenGL 纹理内部格式对应表（部分）}
\label{tab-gl:internal-format-list}
\end{table}

width，height：

分别表示纹理的长和宽，以像素为单位。

border：

必须设为 0，目前没有意义。

format：

表示上传数据的像素格式，可以是 GL\_R，GL\_RG，GL\_RGB，GL\_RGBA 等，
更多格式可以参考 docs.gl 的说明。

type：

表示上传数据的像素单通道类型，
可以取 GL\_UNSIGNED\_BYTE，
GL\_FLOAT 等。与 format 共同组成对上传数据格式的描述。
如：format = GL\_RGB，type = GL\_UNSIGNED\_BYTE 表示
每个像素具有 RGB 三通道，每个通道为 8 位无符号整数，即 24 位色。

data：

指向上传数据的指针，可读区域应至少为 width$\times$height$\times$pixel\_size。
此处使用之前构造的 pixel\_data 即可。

\subsubsection{绘制纹理}

在成功创建纹理后，将纹理绘制出来需要片段着色器的帮助。
前文提到，顶点数据可以保存许多信息，
除位置坐标和颜色外，还可以包括纹理坐标信息。
纹理坐标信息是一个二维坐标，
表示纹理贴图上的一点，
每一维度的范围为 $[0, 1]$，
分别对应纹理贴图长宽的范围。

想要将一个纹理绘制出来，可以用以下数据表示的两个三角形组成的矩形完成：

\begin{lstlisting}
float vertex_buffer[4][6] = {
    {-0.5, -0.5, 0.0, 1.0, 0.0, 0.0},
    {-0.5,  0.5, 0.0, 1.0, 0.0, 1.0},
    { 0.5, -0.5, 0.0, 1.0, 1.0, 0.0},
    { 0.5,  0.5, 0.0, 1.0, 1.0, 1.0}
};

uint32_t index_buffer[6] = {
    0,2,1,
    1,2,3,
};
\end{lstlisting}

其中顶点信息的前四个维度表示齐次坐标四元组 $(x, y, z, w)$，
后两维度表示纹理坐标 $(tx, ty)$。

对应需要修改的还包括 glVertexAttribPointer 函数定义的布局信息，
以及两个着色器，分别修改如下：

顶点布局

\begin{lstlisting}
glVertexAttribPointer(0, 4, GL_FLOAT, false, 24, (void*)0);
glVertexAttribPointer(1, 2, GL_FLOAT, false, 24, (void*)16);
\end{lstlisting}

顶点着色器

\begin{lstlisting}
#version 450 core
layout (location = 0) in vec4 vs_pos;
layout (location = 1) in vec2 vs_texcoord;
out vec2 fs_texcoord;
void main()
{
    gl_Position = vs_pos;
    fs_texcoord = vs_texcoord;
}
\end{lstlisting}

片段着色器

\begin{lstlisting}
#version 450 core
in vec2 fs_texcoord;
out vec4 color;
uniform sampler2D texture0;
void main()
{
    color = texture(texture0, fs_texcoord);
}
\end{lstlisting}

片段着色器中使用了一个新的 uniform 类型 sampler2D（二维采样器），
这个类型的变量用于标记绑定的纹理编号，默认为 0。
其本身不必须被传入参数，
在使用多个纹理时，
可以对该类型变量传入整数值以标记每个 sampler2D 对象对应的纹理编号。
在定义了 sampler2D 类型的变量后，
可以用代码中的方式，
根据纹理坐标，调用 texture 函数进行纹理信息的采样。
采样返回值为 vec4 类型，直接赋予输出的颜色变量即可。

最后，需要在 C/C++ 代码中定义纹理采样的方式，
这一操作同样需要绑定后进行：

\begin{lstlisting}
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
\end{lstlisting}

glTexParameteri 函数用于设置纹理的参数。
这个函数的第二个参数用于指定要进行设置的纹理参数，

GL\_TEXTURE\_MAG\_FILTER 和 GL\_TEXTURE\_MIN\_FILTER
分别表示在纹理被放大或缩小时，
采样器对纹理进行过滤的方法。
GL\_NEAREST 表示取最近点，
采样器会返回距离纹理坐标最近的像素的值，
这样的设置在纹理被放大显示时，
看上去会有很多方格，即被放大的像素；
还可以选择 GL\_LINEAR，表示线性过滤，
采样器会根据不能纹理坐标周围的四个像素的值进行插值计算，
得到采样结果，这样的设置在纹理被放大显示时，
看上去会比较模糊，像素之间的界限不清晰。

GL\_TEXTURE\_WRAP\_S 和 GL\_TEXTURE\_WRAP\_T
用于指定纹理在横纵坐标上的环绕方式，
即当纹理坐标超出 $[0, 1]$ 时，
应该取什么颜色。
几种取值的效果见图 \ref{fig-gl:wrap-mode}。


\begin{figure}
    \centering
    \subfigure[GL\_REPEAT]{
        \begin{minipage}[t]{0.23\linewidth}
        \centering
        \includegraphics[height=1.2in]{imgs/sec 5.2/texture-repeat.png}
        \end{minipage}
    }
    \subfigure[GL\_MIRRORED\_REPEAT]{
        \begin{minipage}[t]{0.23\linewidth}
        \centering
        \includegraphics[height=1.2in]{imgs/sec 5.2/texture-mirror.png}
        \end{minipage}
    }
    \subfigure[GL\_CLAMP\_TO\_EDGE]{
        \begin{minipage}[t]{0.23\linewidth}
        \centering
        \includegraphics[height=1.2in]{imgs/sec 5.2/texture-clamp-edge.png}
        \end{minipage}
    }
    \subfigure[GL\_CLAMP\_TO\_BORDER]{
        \begin{minipage}[t]{0.23\linewidth}
        \centering
        \includegraphics[height=1.2in]{imgs/sec 5.2/texture-clamp-to-border.png}
        \end{minipage}
    }
    \caption{四种环绕方式的效果}
    \label{fig-gl:wrap-mode}
\end{figure}

一切设置完毕，编译运行程序后，运行结果如图 \ref{fig-gl:texture-rendered}。

\begin{figure}[htbp]
\centering
\includegraphics[width=0.5\linewidth]{imgs/sec 5.2/texture.png}
\caption{纹理绘制效果图}
\label{fig-gl:texture-rendered}
\end{figure}

\subsection{高级技术}

这一节的将介绍一些 OpenGL 的高级使用技巧。

\subsubsection{帧缓冲}

到目前为止，所有的绘制指令都是将图像直接绘制到显示窗口的缓冲区的。
但在许多时候，程序需要先将一些中间图像绘制到不可见的缓冲区中，
再通过这些缓冲区中的图像生成最终图像。
这种不直接绘制到窗口缓冲的技术被称作“离屏渲染”。

在 OpenGL 中实现离屏渲染需要用到帧缓冲对象（FrameBuffer）。
一个帧缓冲对象可以保存一组颜色纹理和一个深度纹理，
把帧缓冲对象绑定到渲染流水线上后调用绘制指令，
OpenGL 就会将图像绘制到对应的纹理中。
默认的帧缓冲是由 GLFW 负责创建的，对应窗口区域的颜色缓冲和深度缓冲。
创建一个帧缓冲并绑定一组纹理的方法如下：

\begin{lstlisting}
glCreateFramebuffers(1, &framebuffer_object);
glBindFramebuffer(GL_FRAMEBUFFER, framebuffer_object);
glFramebufferTexture2D(
    GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, 
    depth_texture, 0
);

uint32_t color_attachments[n_render_target];

for (int i = 0; i < n_render_target; i++)
{
    glFramebufferTexture2D(
        GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D,
        color_texture[i], 0
    );
    color_attachments[i] = GL_COLOR_ATTACHMENT0 + i;
}

glDrawBuffers(n_render_target, color_attachments);

glBindFramebuffer(GL_FRAMEBUFFER, 0);
\end{lstlisting}

glCreateFramebuffers 和 glBindFramebuffer 函数功能与其它同类函数类似，不再进行解释。
glFramebufferTexture2D 函数用于将纹理对象绑定到当前帧缓冲中。
其中 GL\_COLOR\_ATTACHMENTi 和 GL\_DEPTH\_ATTACHMENT 用于分别指定颜色缓冲和深度缓冲的绑定点。
由 GL\_COLOR\_ATTACHMENTi 的编号功能可以看出，
颜色缓冲可以有多个。
事实上，一个帧缓冲最多绑定 $32$ 个颜色缓冲，编号从 $0$ 到 $31$，
指定第 $i$ 个绑定点可以直接引用宏常量 GL\_COLOR\_ATTACHMENTi，
也可以通过 GL\_COLOR\_ATTACHMENT0 + i 的方式计算得到。

在将颜色缓冲绑定到绑定点后，还需要用 glDrawBuffers 函数将绑定点对应到颜色输出通道，
以与片段着色器的输出对接。
之前的情况中，由于窗口只包含一个颜色缓冲，故未对片段着色器的输出进行过多修饰。
在多个颜色缓冲的情况下，
片段着色器的输出变量同样可以用 layout (location = $X$) 的方式修饰，以对应不同输出通道的颜色缓冲。
其中 $X$ 即对应了第 $X$ 个通道，即 color\_attachments 数组中第 $X$ 个变量对应的绑定点。

片段着色器中的输出变量完整定义方式如下：
\begin{lstlisting}
layout (location = 3) vec4 color3;
\end{lstlisting}

同一帧缓冲中的缓冲纹理大小不必相同，
实际的绘制区域是由 glViewport 函数指定的。
如果绘制过程中出现了纹理越界的情况，则对应数据会被直接丢弃，
因此，不必过分担心纹理大小对齐的问题。

\subsubsection{混合}

在之前的样例中，片段着色器输出的第四维信息一直没有作用，
这是因为没有开启 OpenGL 的混合功能。
混合技术可以根据新绘制的片段颜色信息与目标缓冲中已经保存的颜色信息进行计算，
得到新的颜色值并保存在目标缓冲中。
这种技术通常被用于实现半透明效果。

调用如下代码启用混合技术。

\begin{lstlisting}
glEnable(GL_BLEND);
\end{lstlisting}

在默认的混合模式下，
若一个新绘制片段的颜色值为 $\left(r_s, g_s, b_s, a_s\right)$，
目标位置已有的颜色值为 $\left(r_d, g_d, b_d, a_d\right)$。
则新的颜色值为 $$\left(\begin{matrix}
    r\\g\\b\\a
\end{matrix}\right)=\left(\begin{matrix}
    r_s\\g_s\\b_s\\a_s
\end{matrix}\right)\times a_s+\left(\begin{matrix}
    r_d\\g_d\\b_d\\a_d
\end{matrix}\right)\times(1.0-a_s)$$。

可以通过 glBlendFunc 函数修改混合方式以实现不同效果，
具体细节可以通过 docs.gl 网站查询获得。

\subsubsection{面剔除}

在光栅化渲染管线中，
渲染的效率往往是和绘制的片段数正相关的，
因此，省去不必要的片段计算可以提高渲染的效率。

对于大多数三维物体而言，它们的几何表示都是封闭的，
这时，不面向观察者的面最终一定不会被绘制出来。
比如一个不透明球体，
其面向观察者的一半有必要进行绘制，
其背向观察者的一面则一定会被面向观察者一面遮挡，故没有必要进行绘制。

面剔除技术可以在三角形进入光栅化阶段之前，
根据三角形朝向进行筛选，将背向观察者的三角形全部剔除，
从而达到节约计算资源的目的。
判断正反向的根据是三角形三个顶点在变换到屏幕空间后的环绕方向，
OpenGL 认为顺时针环绕的三角形是正向的，逆时针环绕的三角形是反向的。
在开启面剔除后，默认剔除反向的三角形。

开启面剔除的代码如下：

\begin{lstlisting}
glEnable(GL_CULL_FACE);
\end{lstlisting}

修改剔除朝向为正向的代码如下：

\begin{lstlisting}
glCullFace(GL_FRONT);
\end{lstlisting}

如果希望改回反向剔除，则可调用：

\begin{lstlisting}
glCullFace(GL_BACK);
\end{lstlisting}


\subsubsection{更多 GLSL 语法}

在 GLSL 中，获取一个向量的分量除了可以通过 vec[i] 的方式调用外，
还可以通过 vec.x, vec.y, vec.z, vec.w 的方式分别访问向量的四个分量，
通过 vec.r, vec.g, vec.b, vec.a 也可以实现同样的效果。
这种字母表示法除了可以获取一个分量外，
还可以通过 vec.zxy 或者 vec.bgr 的方式将其若干个分量重新组合成一个新的分量返回。

在组合新的向量时，也可以用如下方式，将不同维数的向量组合为新的向量，
只需保证参数维数之和等于新的向量维数即可。

\begin{lstlisting}
/* 以下形式的语法都是合法的 */
vec4 v0 = vec4(1.0, 2.0, 3.0, 4.0), v1 = vec4(4.0, 3.0, 2.0, 1.0), vec;
vec = vec4(v1.xzy, v0.x);
vec = vec4(v0.y, v1.xy, 1.0);
vec = vec4(4.0, vec3(3.0, v0.wx));
\end{lstlisting}

在 GLSL 中还有许多内建函数，
如常用的数学函数 sin, cos, tan, asin, acos, atan, radians, degrees, pow, exp, log, exp2, log2, sqrt 等；
常用的向量函数 length, distance, normalize, dot, cross 等；
常用的矩阵函数 determinant, transpose, inverse 等。
GLSL 内建函数同样支持在 docs.gl 查询，在此不再一一说明。

根据前文的内容，顶点着色器使用了内建变量 gl\_Position 向后续光栅化流程指定变换后的顶点坐标。
GLSL 还拥有许多其他内建变量，这些变量有些是可写的，有些则是只读的。
例如，gl\_PointSize 用于指定绘制点的大小，
gl\_FrontFacing 用于获取一个片段是否是正向的，
gl\_FragCoord 用于获取片段在屏幕空间的坐标，
gl\_FragDepth 用于获取片段的深度值等。
所有的内建变量也支持在 docs.gl 查询，不再一一说明。

\subsection{光照}

\begin{figure}[htbp]
    \centering
    \subfigure[无光照]
    {
        \begin{minipage}[t]{0.4\linewidth}
        \centering
        \includegraphics[height=2in]{imgs/sec 7.1/no-lighting.png}
        \label{fig-gl:no-lighting}
        \end{minipage}
    }
    \subfigure[光照及阴影]
    {
        \begin{minipage}[t]{0.4\linewidth}
        \centering
        \includegraphics[height=2in]{imgs/sec 7.1/lighting-with-shadow.png}
        \label{fig-gl:with-lighting}
        \end{minipage}
    }
    \caption{有无光照效果对比}
    \label{fig-gl:lighting-compare}
\end{figure}

在真实感渲染中，光照算法扮演着至关重要的角色。
本节的内容将分析实现光照算法的过程以及可能存在的问题，
最终实现从图 \ref{fig-gl:no-lighting} 到图 \ref{fig-gl:with-lighting} 的蜕变。
不难看出，没有光照效果的图像虽然能表现三维物体的轮廓，
但整体感觉像是一个一个的“贴片”，没有立体感。
而加入光照和阴影效果后，图像立即有了立体感，层次感。

在以往的固定渲染管线中，
光照算法往往是在硬件中实现的，
支持的效果有限，但使用简便。
而在可编程渲染管线中，
开发者可以通过编写不同的着色器实现复杂的光照计算，
但这的确给开发者造成了更多的负担。

\subsubsection{光照原理}

光照计算的根本目的是给绘制的物体赋予正确的亮度值，
而不是像之前的样例中用一个设置好的颜色作为最终的图像颜色。
一个光照算法所计算出的亮度值越接近真实世界的情况，
则这个光照算法所带来的真实感就越强。

在光照计算中，最核心的问题在于定义光源。
光源决定了光是以怎样的方式照亮了场景。
光栅化渲染管线中常用的光源模型有三种：点光源、平行光源和环境光。

点光源模型将光源抽象为一个点，光由该点发出，光的能量密度随着距离的增大而减弱，
光照效果往往作用于局部场景，类似于现实中的灯泡、烛焰等光源。

平行光源将光源抽象为一个具有方向的能量场，所有光线都从一个方向来，
往往作用于整个场景，可以想象成无穷远处的一个点光源，类似于现实中的太阳。

环境光不是对真正的光源的抽象，
而是对在场景中经过许多次反射，
照亮了处于阴影区的物体的那部分光能的抽象。

综合这三种光源类型，可以写出如下进行光照计算的片段着色器框架：

\begin{lstlisting}
vec3 lighting(vec3 frag_pos, vec3 frag_norm, vec3 frag_color)
{
    /* 用于统计被反射到出射光方向的总亮度 */
    vec3 reflected_light = vec3(0.0, 0.0, 0.0);
    /* 计算点光源贡献 */
    reflected_light += point_light(frag_pos, frag_norm);
    /* 计算平行光源贡献 */
    reflected_light += parrallel_light(frag_pos, frag_norm);
    /* 计算环境光贡献 */
    reflected_light += ambient_light(frag_pos, frag_norm);
    /* 最终亮度还需要乘以反射率，以表现物体的颜色 */
    return frag_color * incoming_light;
}
\end{lstlisting}

与观察者观察到的物体亮度密切相关的还包括物体表面的材质，
物体表面的材质决定了一束光线打到这个表面时反射光线的分布。
结合以上两点，可以得到计算光照的公式：

$$L_o=L_i\cos\theta_iR\left(v_i, v_n, v_o\right)$$

其中，
$L_o$ 表示出射光亮度。
$L_i$ 表示入射光亮度。
$\theta_i$ 表示入射光方向与物体表面法线的夹角。
$\cos\theta_i$ 一项表示入射光分摊面积与入射光截面面积之比，
这一项保证了入射角较大时，物体表面亮度会相应降低。
$v_i$ 表示入射光方向，即光源方向。
$v_n$ 表示物体表面法向。
$v_o$ 表示出射光方向，即视点方向。
$R$ 函数表示入射光方向和法向量给定时，
不同出射光方向的亮度系数，
这一项主要用于表现不同材质的表面，
故且称之为“反射模型函数”；
这个函数形式上十分类似双向反射分布函数(BRDF)，
只不过为了简化表述，
它可以省去许多基于物理规则的约束，
以更直观地作用于最终图像。

在实际实现中，以上公式主要作为一个参考，
因为光栅化渲染不能完美地模拟物理的光照过程，
实际的代码会包含很多经验性的人工设计元素以贴合真实感的效果，
从而使画面更美观。
但经验的东西往往不会过于偏离基本原理，
因此可以由以上公式得出适用于不同光照模型的通用伪代码：

\begin{lstlisting}
vec3 xxx_light(vec3 frag_pos, vec3 frag_norm)
{
    vec3 vIn = normalize(light_direction);
    vec3 vNorm = frag_norm; 
    vec3 vOut = normalize(camera_pos - frag_pos);
    float cos_theta_i = max(dot(vNorm, vIn), 0.0);
    return 
    incoming_light(frag_pos) * 
    cos_theta_i * 
    reflect_model(vIn, vNorm, vOut);
}
\end{lstlisting}

接下来，只需要确定入射光亮度函数 incoming\_light 
和反射模型函数 reflect\_model，
即可完成光照着色器的编写。

\subsubsection{实现光源}

对于点光源，入射光亮度会随着距离的增加而衰减。
如果严格按照符合物理规律的平方反比率计算衰减，
得到入射光亮度公式为 $L_i=\frac{I}{d^2}$。
其中 $I$ 为点光源的强度，$d$ 为点光源位置到物体表面点的距离。
但这样的公式在 $d$ 趋近于 $0$ 时，计算得到的亮度会趋于 $+\infty$，
体现到图像上就会变成一个特别亮的光斑，
十分不美观。
因此，在实现点光源时，通常会将衰减项增加一个一次项和一个常数项，
公式变为 $L_i=\frac{I}{k_qd^2 + k_pd + k_c}$。
$k_q$ 为二次项系数，$k_p$ 为一次项系数，$k_c$ 为常数项系数。
这三个系数可以完全自定义，从而实现不同的光照效果。
综上可得如下计算点光源贡献的函数：
\begin{lstlisting}
vec3 point_light(vec3 frag_pos, vec3 frag_norm)
{
    vec3 vLight = light_pos - frag_pos;
    vec3 vIn = normalize(vLight);
    vec3 vNorm = frag_norm; 
    vec3 vOut = normalize(camera_pos - frag_pos);
    float cos_theta_i = max(dot(vNorm, vIn), 0.0);
    float d = length(vLight);
    return 
    (light_brightness / (Kq*d*d + Kp*d + Kc)) * 
    cos_theta_i * 
    reflect_model(vIn, vNorm, vOut);
}
\end{lstlisting}

对于平行光源，入射光亮度一般为常数，
因为平行光源的亮度不会跟随距离发生变化。
而平行光源的入射光方向也是确定的，
因此，计算平行光源贡献的函数相对简单：
\begin{lstlisting}
vec3 parallel_light(vec3 frag_pos, vec3 frag_norm)
{
    vec3 vIn = normalize(parallel_light_direction);
    vec3 vNorm = frag_norm; 
    vec3 vOut = normalize(camera_pos - frag_pos);
    float cos_theta_i = max(dot(vNorm, vIn), 0.0);
    return 
    parallel_light_brightness * 
    cos_theta_i * 
    reflect_model(vIn, vNorm, vOut);
}
\end{lstlisting}

对于环境光，其物理过程最为复杂。
这种类型的光照没有统一的出发点，
没有统一的方向，因此很难准确地进行计算。
但由于其存在于整个场景，
在不考虑严谨性的情况下，
将环境光近似为一个无处不在的亮度均值即可得到不错的效果。
因此，模拟环境光的代码十分简单，返回一个常数即可：

\begin{lstlisting}
vec3 ambient_light(vec3 frag_pos, vec3 frag_norm)
{
    return ambient_constant;
}    
\end{lstlisting}

这样的近似肯定是失真的，
它的主要作用是防止没有其他类型的光照可达的区域变成一片漆黑，
当完全没有其他类型的光照，且环境光为 $(1.0, 1.0, 1.0)$ 时，
效果等同于没有考虑光照时，直接将物体颜色绘制出来。

对于环境光的探索肯定不会止步于如此简单的模型，
研究者们提出了很多用于改进环境光效果的方法，
比如在大型 3D 游戏的画面设置中常见的 “环境光遮蔽”。
这类方法可以改善场景中一些细节处的层次细节，
比如缝隙，墙角，衣服褶皱等。
此类方法的原理和实现较为复杂，
在此不再进行展开，
可以自行查阅相关资料进行学习。

\subsubsection{实现反射模型}

反射模型决定了物体表面的质感，
现实生活中，有的物体粗糙，有的物体光滑。
当一束光照到物体表面时，
物体表面的性质决定了出射光的分布情况。

对于粗糙表面，应用的反射模型为漫反射模型。
在理想情况下，无论入射光的方向为何，其产生的出射光都是均匀分布的。
当入射光不变时，从任何角度观察这个表面，所观察到的亮度都是相同的。
这种理想漫反射模型被称作“朗伯(Lambertian)模型”，
对应的反射模型函数也十分简单，无论入射光方向、物体表面法向、出射光方向为何，返回一个常数即可：

\begin{lstlisting}
float lambertian_reflect_model(vec3 vIn, vec3 vNorm, vec3 vOut)
{
    return 1.0;
}
\end{lstlisting}

通过漫反射模型，可以绘制出如图 \ref{fig-gl:lambertian-model} 所示的效果。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\linewidth]{imgs/sec 7.1/lighting.png}
    \caption{漫反射模型的效果}
    \label{fig-gl:lambertian-model}
\end{figure}

可以看出，应用漫反射模型后，所得到的效果相比无光照的效果已经有了非常大的提升。
但如果场景中的物体都是漫反射表面，未免有些太过单调。
因此，除漫反射模型外，渲染器一般还会实现镜面反射模型。
需要注意的是，镜面反射模型并不是严格遵循反射定律的模型，
它近似的并不是完美的镜面，而是一个相对光滑的，
出射光在镜面反射出射方向附近分布较多的表面。

为了便于理解镜面反射模型中的设计，需要引入“微表面模型”的概念。
如前文所述，
物体表面的性质是用一个和入射光方向，出射光方向和物体表面法向相关的分布函数表示的，
直接构造一个这样的分布函数容易变成描述出射光方向的特征，而非物体表面性质的特征。
换一种视角思考，直接从物体表面的性质出发，
想象物体的表面实际上是由许多细小的微表面构成，
这些微表面具有自己的法向。
当入射光线抵达微表面时，严格按照微表面法向及反射定律产生出射光。
当需要描述物体表面的性质时，只需要描述微表面法向的分布即可。
可以想象，当微表面法向分布集中于真正的物体表面法向附近时，物体表面的宏观表现较为光滑；
当微表面法向分布较为混乱时，物体表面的宏观表现较为粗糙。
当构造一个反射模型函数时，可以先定义出微表面法向的分布函数，
再由入射光方向和出射光方向计算出对应的微表面法向，
进而得到反射模型的分布。
由入射光方向 $v_i$ 和出射光方向 $v_o$ 计算得到的“微表面法向”被称作“半向量”，
因为计算的方法就是入射光方向和出射光方向各取一半，再进行归一化。
得到半向量计算公式 $v_{h} = \text{normalize}(v_i + v_o)$。

由微表面模型构造的反射模型函数具有如下形式：

$$
R(v_i, v_n, v_o) = M(v_h, v_n)
$$

函数 $M$ 是描述微表面法向分布的函数。
在著名的 Blinn-Phong 模型中，$M$ 函数的定义如下，其中 $shininess$ 表示物体表面的光亮度，
光亮度越高，微表面法线分布越集中与宏观表面发现附近，从而产生更光滑的效果：

$$
M_{\text{Blinn\_Phong}}(v_h, v_n)=dot(v_h, v_n)^{shininess}
$$

注：Blinn-Phong模型本身不是用微表面模型描述的，但可以用微表面模型进行理解。
此外，由于Blinn-Phong模型本身不带有 $\cos\theta_i$ 项，
故将上述函数带入前文中的框架中也并非原始的 Blinn-Phong 模型。
但由于 Blinn-Phong 本身为经验模型，而非物理模型，
故在其基础上进行一些修改也无伤大雅，不会造成更多的错误，
应看重其启发意义。

由上述理论可以设计得到光滑表面的反射模型函数：

\begin{lstlisting}
float specular_reflect_model(vec3 vIn, vec3 vNorm, vec3 vOut)
{
    vec3 vHalf = normalize(vIn + vOut);
    return pow(max(dot(vHalf, vNorm), 0), 100);
}
\end{lstlisting}

将其叠加在漫反射模型上后，绘制出的图像效果如图 \ref{fig-gl:high-light} 所示。
可以看到，图像中的小球都绘制出了高光效果。

\begin{figure}[htbp]
\centering
\includegraphics[width=0.5\linewidth]{imgs/sec 7.1/high-light.png}
\caption{得到高光效果}
\label{fig-gl:high-light}
\end{figure}

基于反射模型的功能十分强大，本小节所示的两个样例仅仅是冰山一角，
利用不同的反射模型可以绘制出许多不同的物体材质。
如前文所述，本节内容中使用的“反射模型函数”本质上是双向反射分布函数（BRDF）的变种，
在工业界，已经存在许多复杂的 BRDF，
如迪士尼公司提出的“迪士尼原则的 BRDF”，
它允许艺术工作者使用许多直观的参数描述不同观感的材质，
兼具强大功能性与易用性。
相关资料十分丰富，可自行查阅。

\subsubsection{绘制阴影}

上一小节中，实现了光照效果后绘制出的图片的内容已经十分丰富了。
但是，物体在光照条件下没有产生阴影，使得画面中的物体看上去有些“漂浮感”。
然而，在光栅化管线中绘制阴影不是一件十分容易的事，
因为阴影是由物体遮挡光源发出的光线形成的，
判断物体上一点与光源的连线上是否存在遮挡物需要涉及大量的几何计算。
光栅化管线恰恰是为了避免这种计算而设计的。
因此，想要实现阴影效果需要一些取巧的方法。

在图形学研究早期，学术界提出了很多种阴影渲染的方法，
但在经过大量实际应用的筛选后，
绝大多数应用都选择了阴影映射算法。
阴影映射算法的核心思想非常简单且直观，
同时，其算法流程完美地复用了光栅化管线功能，
而不用引入额外的处理流程。这些优点使得它在众多阴影算法的角逐中胜出。

阴影映射算法的核心思想是：
“光源能够照射到的部分，和处在光源出发点所能“看到”的部分本质相同。”
具体地，回忆下在正常的渲染管线中用于处理物体之间遮挡关系的深度缓冲。
深度缓冲可以用来测量一个物体在观察者视角下有没有被遮挡，
同样的，它也可以用于测量一个物体在光源视角下有没有被遮挡。

根据以上核心思想，可以得到阴影映射算法的流程：
首先，绘制一张在光源视角下的深度缓冲图像，称作阴影贴图，如图 \ref{fig-gl:shadow-map} 所示，
然后，在正常绘制图像时，对于每个绘制的片段，
根据阴影贴图判断其所处位置在光源视角下是否被遮挡，
如没有被遮挡，则计算光源对该片段的光照贡献，否则贡献为 $0$。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\linewidth]{imgs/sec 7.2/shadow_map.png}
    \caption{阴影贴图（与深度缓冲本质相同）}
    \label{fig-gl:shadow-map}
\end{figure}

在绘制光源视角的深度缓冲时，需要用到基于帧缓冲的离屏渲染，并关闭帧缓冲对象的色彩通道，代码如下：
\begin{lstlisting}
glCreateFramebuffers(1, &shadow_map_framebuffer_object);
glBindFramebuffer(GL_FRAMEBUFFER, shadow_map_framebuffer_object);
glFramebufferTexture2D( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
GL_TEXTURE_2D, shadow_map_object, 0);
glDrawBuffer(GL_NONE);
glReadBuffer(GL_NONE);
glBindFramebuffer(GL_FRAMEBUFFER, 0);
\end{lstlisting}

同时，需要为绘制阴影贴图编写一套简单的着色器。

阴影贴图顶点着色器（只需要坐标变换）：
\begin{lstlisting}
#version 450 core
layout (location = 0) in vec3 vs_pos;
uniform mat4 mat_trans;
void main()
{
    gl_Position = mat_trans*vec4(vs_pos, 1.0);
}
\end{lstlisting}

阴影贴图片段着色器（不需要绘制颜色，因此置空即可）：
\begin{lstlisting}
#version 450 core
void main() {}
\end{lstlisting}

在最终图像的绘制中，需要在片段着色器中利用如下函数根据阴影贴图计算光源贡献：

\begin{lstlisting}
uniform sampler2D shadow_map;
uniform mat4 mat_shadow_trans;
float CheckLightVisibility(vec4 pos)
{
    /* 光源坐标变换 */
    pos = mat_shadow_trans*pos;
    /* 从 [-1, 1] 映射到 [0, 1] */
    pos = (pos + vec4(1.0, 1.0, 1.0, 0.0)) * 0.5;
    return (pos.z <= texture(shadow_map, pos.xy).z) ? 1.0 : 0.0;
}
\end{lstlisting}

以上代码中，阴影贴图着色器中的 mat\_trans 与最终画面片段着色器中的 mat\_shadow\_trans 相同。
此外需要注意，
因为 NDC 空间坐标范围为 $[-1, 1]$，
而纹理采样坐标范围和记录值的范围为 $[0, 1]$，
需要手动进行映射以采样到正确的深度值。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\linewidth]{imgs/sec 7.1/self-occulusion.png}
    \caption{带有阴影的图像（但似乎有些不对）}
    \label{fig-gl:self-occulusion}
\end{figure}

在完成上述代码的实现后，可以获得如图 \ref{fig-gl:self-occulusion} 所示的效果。
从图中可以看到，图像中的小球已经可以正确地投射出阴影了，但物体上出现了奇怪的花纹。
这是因为，阴影贴图的精度有限，本应被照亮的一块区域对应到了阴影贴图的同一像素上。
由于像素只能记录一个深度值，同一区域内部分位置离光源稍远，于是被认为处在阴影区域内，
造成了“自遮挡”现象。
解决此类问题最为简单的方法是将阴影贴图记录的深度稍稍放大一点，以扩大对邻近区域深度变化的容忍度。
在代码上体现为，
将上文判断光源可见性的函数中采样到的阴影贴图深度乘以
$(1+\epsilon)$（此处取$\epsilon=0.001$）后，再与片段深度做比较：

\begin{lstlisting}
return (pos.z <= texture(shadow_map, pos.xy).z * 1.001) ? 1.0 : 0.0;
\end{lstlisting}

这种解决方案并不完美，
例如：在光源方向与物体法向夹角过大时问题依旧会存在；
以及引入深度容忍度会使本应处于阴影中的区域被照亮，
从而产生“漏光”或者“漂浮”现象。
这些问题并没有完美的解决方案，还需要根据实际情况进行具体分析。

由阴影贴图精度不够导致的问题还有阴影锯齿现象，如 \ref{fig-gl:shadow-non-aa} 所示。
通过提高阴影贴图分辨率可以一定程度上缓解问题，
另一种比较有效的手段是，
在计算光源可见性时，
对阴影贴图对应点周围多个像素进行采样，
计算结果的平均值，
从而达到柔化阴影边缘的效果，
如图 \ref{fig-gl:shadow-with-aa} 所示。
两种方法中，前者会造成更多的显存负担，
后者会造成更多的计算负担。
一般情况下，后者生成的图像观感更好。

\begin{figure}[htbp]
    \centering
    \subfigure[阴影锯齿]
    {
        \begin{minipage}[t]{0.4\linewidth}
        \centering
        \includegraphics[height=2in]{imgs/sec 7.1/part-lighting-no-aa.png}
        \label{fig-gl:shadow-non-aa}
        \end{minipage}
    }
    \subfigure[经过柔化处理的阴影]
    {
        \begin{minipage}[t]{0.4\linewidth}
        \centering
        \includegraphics[height=2in]{imgs/sec 7.1/part-lighting-with-shadow.png}
        \label{fig-gl:shadow-with-aa}
        \end{minipage}
    }
    \caption{阴影抗锯齿前后对比}
    \label{fig-gl:shadow-aa-compare}
\end{figure}

在应用了上述优化方法后，最终可以得到如图 \ref{fig-gl:lighting-with-shadow} 所示的效果。

\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{imgs/sec 7.1/lighting-with-shadow.png}
    \caption{带有阴影的效果图}
    \label{fig-gl:lighting-with-shadow}
\end{figure}

\subsection{更多学习资源}

\label{sec-gl:study-resources}

\href{https://docs.gl}{docs.gl，OpenGL 函数资料库：https://docs.gl/}

\href{https://learnopengl.com/}{Learn OpenGL，一个出色的 OpenGL 教程：https://learnopengl.com/}

\href{https://learnopengl-cn.github.io/}{Learn OpenGL 中文翻译版：https://learnopengl-cn.github.io/}

\end{document}
