\documentclass[fontset=windows]{ctexart}
\usepackage{amsmath,amssymb}
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{fullpage}
\usepackage{setspace}
\usepackage{verbatim}
\usepackage[colorlinks,linkcolor=blue]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{xeCJK}
\setmainfont{Times New Roman}
% \setCJKmainfont{SimSun}
\setCJKmonofont{Consolas}
\newCJKfontfamily[kai]\kaiti{KaiTi}
\newCJKfontfamily[HWkai]\hwkaiti{STKaiti}
% \newCJKfontfamily[hei]\heiti{SimHei}
% \newCJKfontfamily[song]\songti{SimSun}
\newfontfamily\consolas{Consolas}
\lstset{
    columns=fixed,       
%    numbers=left,                                        % 在左侧显示行号
	frame=none,                                          % 不显示背景边框
	basicstyle=\consolas,
    backgroundcolor=\color[RGB]{245,245,244},            % 设定背景颜色
    keywordstyle=\consolas\color[RGB]{40,40,255},                 % 设定关键字颜色
	numberstyle=\consolas\color[RGB]{0,255,0},           % 设定行号格式
    commentstyle=\hwkaiti\consolas\color[RGB]{0,96,96},                % 设置代码注释的格式
    stringstyle=\consolas\color[RGB]{255,0,0},   % 设置字符串格式
    showstringspaces=false,                              % 不显示字符串中的空格
    %language=c++,                                        % 设置语言
}
\onehalfspacing
\title{\bf\huge 计算机图形学基础教程}
\author{清华大学\ 计算机科学与技术系}
\date{\today}

\begin{document}
\maketitle

%\hwkaiti{}
% \renewcommand{\contentsname}{目录}
% \renewcommand{\figurename}{图 }

\tableofcontents

\newpage

\section{OpenGL 教程}

\subsection{OpenGL 概述}

\emph{}

OpenGL 是一套开放标准的跨平台高性能图形 API，可以帮助使用者快速创建高性能图形应用程序。
自发布以来，OpenGL 由于其开放性、易用性、可移植性等诸多优点，被广泛地应用在各类图形软件中。

OpenGL的前身是美国硅图公司（Silicon Graphics Inc, SGI）为其图形工作站开发的专有图形接口 IRIS GL。
由于当时不同组织设计的图形硬件设备使用的接口都是专有化的，
图形软件开发者不得不为每种硬件编写不同的代码，
这使得开发图形软件的成本十分昂贵。
20世纪90年代初，SGI 公司意识到了可移植性的重要性，针对性地修改了 IRIS GL 的接口，
移除了其中与特定系统相关的内容，将其作为开放标准发布，即 OpenGL。

1992 年 OpenGL 1.0 版本发布，之后历经二十余年的发展，迭代至今已发布至 4.6 版本。
其维护组织也从 OpenGL 架构审查委员会（OpenGL ARB）转为 Khronos Group。
随着计算机图形硬件的发展，现代图形 API 也逐渐向更加通用的计算发展。
如今，OpenGL 已经几乎停止更新，Khronos Group于2015年发布了其继任者 Vulkan API 标准。
新的标准采用了更底层，更灵活的接口设计，更加适应现代的程序开发模式。
但由于新的接口标准过于复杂，涉及到许多硬件资源的管理问题，对于图形学学习者并不够友好。
OpenGL 在图形应用方面提供了足够强的通用性，并保持着足够好的易用性，
因此其依然是许多情况下最合适的选择。

\subsection{OpenGL 开发环境搭建}

\subsubsection{OpenGL 库}

\emph{}

由于 OpenGL 是一个开放标准，
这使得其接口函数的实现是由不同的图形硬件厂商（如：NVIDIA，AMD，Intel，等）
通过各自的硬件驱动程序提供的。

这样的情况导致许多初学者找不到调用 OpenGL 的方法，因为并不存在一个叫做 OpenGL 的库。
想要调用 OpenGL 函数，必须先从硬件驱动程序中提取出 OpenGL 函数接口。
但由于硬件厂商可能存在不同，驱动程序的位置也往往是不确定的，这给开发者带来了很大的困扰。
针对这个问题，诞生了许多第三方库。
这些第三方库可以帮助开发者完成 OpenGL 环境的创建以及接口函数的提取，
它们往往本身只提供少量几个额外的专有接口用于初始化等操作，
且这些第三方库本身也是跨平台且开源的，
因此可移植性不会受到影响，可以放心使用。
OpenGL 支持多种常见的编程语言，如：C，C++，Python，Java，等。
本章内容只介绍其在 C/C++ 环境中的使用方法，其他语言的接口定义与 C/C++ 版本基本一致，
如有需要可以非常方便地进行迁移。

本章接下来的教程将使用 GLFW 和 GLAD 这两个第三方库作为样例。
这两个库到本书修订时维护状态较好，故推荐优先选择。
其中 GLFW 负责窗口及环境创建，GLAD 负责提取 OpenGL 接口函数。
其他具有相同功能的库，如：GLUT，GLEW，等，使用方法大同小异，故不再一一介绍。

\subsubsection{Windows 环境搭建}

\label{sec-gl:build-windows-env}

在 Windows 系统上的 OpenGL 环境搭建推荐选择 Visual Studio IDE，
本段将以 Visual Studio 2022 Community 为平台演示基于 GLFW 和 GLAD 的 OpenGL 开发环境搭建流程。

1. 获取 GLFW

前往 \href{https://www.glfw.org/}{GLFW 官方网站 （https://www.glfw.org/）}，
从网站主页顶部导航栏进入 “Download（下载）” 页面，
找到 “Windows pre-compiled binaries（Windows 预编译二进制文件）” 部分，
下载你所要编译的程序的位数（注意，不是操作系统位数，而是你要生成的应用程序位数）的版本的文件。
现代的操作系统和应用程序一般都已升级到 64 位，故此处以 64 位版本为例，
点击 “64-bit Windows binaries（64位 Windows 二进制文件）” 按钮，
即可下载得到一个包含 GLFW 最新版本头文件，及支持各种 Windows 平台编译工具链的链接库文件的压缩包。
将该压缩包解压后先保存在一个位置，以方便之后使用。


\begin{figure}[htbp]
    \centering
    \includegraphics[width = 0.5\linewidth]{imgs/sec 2.2/glfw-download-page.png}
    \centering
    \caption{本书修订时 GLFW 下载页面布局}
    \label{fig-gl:glfw-download-page}
\end{figure}


2. 获取 GLAD

前往 \href{https://glad.dav1d.de/}{GLAD 官方网站（https://glad.dav1d.de/）}，
可以看到一个配置页面，这个页面是配置用来生成适用于不同平台的 GLAD 库文件信息的。
对于个人计算机开发环境，我们只需要将 “API-gl” 一栏选择为 “Version 4.6（本书修订时的最新版本）”，
Profile 一栏选择为 “Core”，如图 \ref{fig-gl:glad-generate-settings} 所示，其他选项保留默认设置，然后点击右下角的 “GENERATE” 按钮，
即可获得合适的 GLAD 版本（本书修订时，点击 “GENERATE” 按钮后，页面会跳转到一个资源列表页面，下载其中的压缩包即可）。
下载到的 GLAD 库包含一个 include/ 文件夹和一个 src/ 文件夹，
分别存放有调用 GLAD 所需要的头文件以及对应的源码。
GLAD 不需要任何形式的链接库，只需要在引用其头文件后，
将其源码加入项目工程即可使用。

\begin{figure}[htbp]
    \centering
    \includegraphics[width = 0.7\linewidth]{imgs/sec 2.2/glad-generate-settings.png}
    \centering
    \caption{GLAD 生成配置（以本书修订时的情况为参考）}
    \label{fig-gl:glad-generate-settings}
\end{figure}

3. 创建 Visual Studio 项目

在进行这一步之前，请先确定系统中已经安装好 Visual Studio， C++ 语言支持，以及 “Windows SDK”，
因为最新版本的 Visual Studio 可以动态配置支持的语言以及拓展工具，
如没有安装 C++ 语言支持，或没有安装 “Windows SDK”，则后续步骤可能无法正常进行。

以 Visual Studio 2022 Community 版本为例。
在准备好以上内容后，进行以下步骤：

- 打开 Visual Studio

- 选择 “创建新项目”

- 选择 “Windows 桌面向导”

- 为项目起一个名称，并选择保存位置，点击 “创建”

- 选择 “控制台应用程序”，并勾选 “空项目”，点击 “确定” 完成项目创建

在项目创建完成后，Visual Studio 会自动打开新创建的项目。
此时，在 “解决方案资源管理器” 中可以看到整个项目的组织结构。
右键点击其中的 “源文件”，依次点击 “添加”-“新建项”；
在弹出的窗口中选择 “C++文件(.cpp)”，
编辑文件名称（如 “main.cpp”），并点击右下角的 “添加”，
即可为新创建的空项目添加一个空的源文件。

在这个新创建的源文件中，可以尝试编写一个 “Hello, World” 程序，按 F5 编译运行，以测试基础环境是否配置正确。

Visual Studio 的功能非常强大，可以配置的选项十分繁复，此处特别提醒：在顶部导航栏可以选择生成应用程序的模式。
Visual Studio 2022 默认为 “Debug-x64”，其中 “Debug” 表示以调试模式编译，
“x64” 表示生成 64 位应用程序。“Debug” 模式默认不开启任何优化，
因此生成的程序运行速度非常慢，如果希望编译高效率的程序，可以将此选项改为 “Release”。
注意，更早版本的 Visual Studio 可能默认目标平台为 “x86”，即 32 位应用程序，
需要手动修改为 “x64” 以适配教程中默认采用的 64 位链接库。

4. 将 OpenGL 库添加到项目中

在进行这一步之前，建议将下载好的 GLFW 和 GLAD 文件移动到项目文件夹中，
以确保项目在迁移到其他设备上时可以正常工作。

为了在编译应用程序时，编译工具能够正确地找到两个第三方库的相关文件，
需要向 Visual Studio 项目添加第三方库的头文件包含目录以及库目录信息，
并将需要用到的静态链接库添加到链接器的配置中。

具体的操作方法为：

在 Visual Studio 窗口顶部导航栏中选择 “项目”-“XXX 属性”（XXX 替换为你的项目名称），
弹出项目属性页。

在属性页顶部首先选择好对应的生成配置，
然后在左侧配置属性中选择 “VC++目录”，
在右侧找到 “包含目录” ，将 GLFW 和 GLAD 文件包中 include/ 目录的路径添加到该项的值中。
再在右侧找到 “库目录” ，将 GLFW 文件包中对应编译工具版本的目录路径添加到该项的值中，
例如，Visual Studio 2022 应选择 “your-glfw-path/lib-vc2022”。

在目录配置完成后，在左侧配置属性中选择 “链接器”-“输入”，
在右侧找到 “附加依赖项”，将 “glfw3.lib” 添加到该项。

最后，保存修改的信息并关闭项目属性页，回到 “解决方案资源管理器”，
右键“源文件”-“添加”-“现有项”，找到 GLAD 文件包中的 src/ 目录，
将其中的 glad.c 文件添加到项目中。

至此，Windows 平台上的 OpenGL 环境配置完毕。
请跳转到 \ref{sec-gl:creating-opengl-window} 节继续阅读。

\subsubsection{Linux 环境搭建}

本节以 Ubuntu-20.04 版本为例，演示在 Linux 平台上的 OpenGL 环境搭建方法。
用于其他 Linux 发行版的方法
可以参考其中共同的部分，
并将和 Ubuntu 系统软件包管理相关的操作替换成对应系统的软件包管理操作。
在搭建 Linux 平台环境之前，请确保所使用的 Linux 平台包含有窗口服务，
否则程序无法正常运行。
一般桌面端的 Linux 发行版都满足此条件，
而服务器端则可能不支持。

1. 获取 GLFW

不同于 Windows 平台，由于 Linux 平台不同发行版之间存在或多或少的差异，
很难提供一套统一的预编译二进制文件。
故，在 Linux 平台上使用 GLFW 库需要通过其开源代码自行编译静态链接库文件。

首先，与 Windows 平台相同，
前往\href{https://www.glfw.org/}{GLFW 官方网站 （https://www.glfw.org/）}
的下载页下载所需的文件。
点击 “Source package（源代码包）” 按钮，获得 GLFW 源代码的压缩包并解压。
进入解压后的文件目录，可以看到一个 CMake 工程的文件结构。

在 GLFW 目录下运行以下指令，以编译安装 GLFW 库文件到系统库目录。

\begin{lstlisting}[language=bash]
sudo apt update
sudo apt install g++ cmake xorg-dev libglu1-mesa-dev
mkdir build
cd build
cmake ..
make
sudo make install
\end{lstlisting}

如未能成功运行以上指令，
可能是系统所使用的软件包管理器不同，
或是缺少一些未被上述指令考虑在内的依赖包，
亦或是权限问题，可以根据问题提示自行搜索解决方案。

2. 获取 GLAD

获取 GLAD 库文件包的方法与 Windows 平台相同，请参考 \ref{sec-gl:build-windows-env} 节对应部分内容。

3. 创建项目代码

在上述操作完成后，在一个合适的位置创建一个项目目录，以下将使用 “project-path/” 代表项目目录。
在创建项目目录后，在项目目录中创建 include/ 目录， makefile 文件及源文件 main.cpp。
然后，将 GLFW 和 GLAD 文件包中的 include/ 目录下的内容复制到 project-path/include/ 目录下；
同时，将 GLAD 文件包中 src/目录下的 glad.c 文件复制到 project-path/ 目录。

此时，项目目录下的文件结构应该如下所示：

\begin{lstlisting}
project-path
├── glad.c
├── include
│   ├── glad
│   │   └── glad.h
│   ├── GLFW
│   │   ├── glfw3.h
│   │   └── glfw3native.h
│   └── KHR
│       └── khrplatform.h
├── main.cpp
└── makefile
\end{lstlisting}

最后，编辑 makefile 文件，写入如下内容

\begin{lstlisting}[language=make]
main: main.cpp glad.c
    g++ main.cpp glad.c -Iinclude -o main -m64 -lglfw3 -lX11 -ldl -pthread
\end{lstlisting}

完成后，即可通过在项目目录下运行如下指令进行程序的编译和运行。

\begin{lstlisting}[language=bash]
make
./main
\end{lstlisting}

\subsubsection{创建 OpenGL 窗口}

在配置好开发环境后，将源文件编写为如下内容，然后编译运行。

\begin{lstlisting}[language=c++]
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <iostream>

int main(void)
{
    GLFWwindow* window;

    /* 初始化 GLFW 库 */
    if (!glfwInit())
        return -1;

    /* 创建窗口 */
    window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* 将窗口设置为当前上下文 */
    glfwMakeContextCurrent(window);

    /* 初始化 GLAD 库，在这一步之后才能调用 glXXX 函数 */
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        glfwTerminate();
        return -1;
    }

    /* 显示设备信息以及 GL 版本 */
    std::cout << "GPU:         " << glGetString(GL_RENDERER) << std::endl;
    std::cout << "GPU Vendor:  " << glGetString(GL_VENDOR) << std::endl;
    std::cout << "GL Version:  " << glGetString(GL_VERSION) << std::endl;

    /* 消息循环 */
    while (!glfwWindowShouldClose(window))
    {
        /* 在这里实现渲染代码 */
        glClearColor(0.6, 0.7, 0.8, 1.0);
        glClear(GL_COLOR_BUFFER_BIT);

        /* 交换缓冲 */
        glfwSwapBuffers(window);

        /* 处理窗口消息 */
        glfwPollEvents();
    }

    glfwTerminate();
    return 0;
}
\end{lstlisting}

如果所有配置都没有错误，即可看到一个 $640\times 480$ 的窗口，如图\ref{fig-gl:hello-window}所示。
同时，控制台会显示出使用的 GPU 设备型号，制造商，以及支持的 OpenGL 版本信息。
如下所示：

\begin{figure}[htbp]
    \centering
    \includegraphics[width = 0.5\linewidth]{imgs/sec 2.4/hello-window.png}
    \caption{代码正常运行时应当显示的窗口}
    \label{fig-gl:hello-window}
\end{figure}

\begin{lstlisting}
GPU:         NVIDIA GeForce RTX 3090/PCIe/SSE2
GPU Vendor:  NVIDIA Corporation
GL Version:  4.6.0 NVIDIA 497.29
\end{lstlisting}

以此为例：
第一行显示使用的显卡名称；
第二行显示显卡厂商；
第三行显示 OpenGL 版本，第一个版本号表示 OpenGL 接口支持的版本，
第二个版本号表示显卡驱动的版本。

如果 OpenGL 未能运行在正确的设备上，
比如：对于同时具有集成显卡和独立显卡的系统，OpenGL 选择了低性能的集成显卡。
则可能需要在操作系统中手动设置图形硬件优先级。
如果发现支持的 OpenGL 版本过低，可能是驱动程序过于老旧，
此时应该及时更新最新的驱动程序。
如更新驱动程序后问题依旧不能解决，
则可能是显卡设备本身过于老旧，无法支持新版本的接口，
但一般不会发生此类情况。

\label{sec-gl:creating-opengl-window}

如果到此处所有功能运行正常，则可顺利进入图形绘制部分代码的编写。

\subsection{绘制三角形}

现代图形 API 普遍以三角形为基本元素进行绘制。
一般来说，在成功创建窗口后，
接下来要做的就是绘制一个三角形，
由此打开通往高性能图形应用开发的大门。
因此 “Hello, Triangle” 就相当于图形领域的 “Hello，World”，
成为了使用任何图形接口进行开发的第一课。

\subsubsection{顶点缓冲}

想要绘制一个三角形，
首先需要定义出这个三角形的样子。
而定义一个三角形最简单的方法就是给出其三个顶点的位置。
在二维空间中，三角形的一个顶点可以用一个二元组表示，
在三维空间中，三角形的一个顶点可以用一个三元组表示；
但这不是顶点在现代化的图形 API 中真正的表示方法。
现代图形 API 普遍用一个四元组表示一个三维坐标，
这种表示法被称作 “齐次坐标”，
额外的那个维度可以理解为坐标的 “缩放反比”。
例如，一个四元组 $(x,y,z,w)$ 所表示的三维坐标为
$(\frac{x}{w},\frac{y}{w},\frac{z}{w})$。
一般情况下，$w=1$；而当 $w=0$ 时，该四元组表示 $(x,y,z)$ 向量。
这种表示法可以带来诸多好处，这部分内容将在 \ref{sec-gl:projection-matrix} 节详细展开。

除了顶点的位置信息之外，一个顶点可能还会包括颜色，法向量，纹理坐标等服务于渲染的其他信息。
为了简化绘制复杂性，目前阶段对于一个顶点只考虑其位置和颜色信息。
这两个信息分别可由一个四元组表示，位置信息为齐次坐标 $(x,y,z,w)$，
而颜色信息为三通道颜色加上 alpha 通道 $(r,g,b,a)$。
于是，可以用如下方式定义一个三角形的三个顶点的数据：

\begin{lstlisting}[language=c++]
float vertex_buffer[3][8] = {
    { 0.0f,  0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f},
    { 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f},
    {-0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f},
};
\end{lstlisting}

其中每一个八元组的前四个元素表示 $(x,y,z,w)$，后四个元素表示 $(r,g,b,a)$。
对于在二维平面上绘制的情况，坐标的第三维度暂时没有意义，故置为 $0$；
alpha 通道默认为 $1$。

定义好三角形的顶点数据后，需要将这些定点信息传入 GPU 用于绘制。
但 CPU 与 GPU 之间的通信是一个开销非常大的操作，
为了提高应用程序的执行效率，
需要尽可能减少 CPU 与 GPU 之间的通信次数。
因此，为了避免每一帧的绘制都需要将绘制过程的资源从 CPU 端传到 GPU 端，
现代化的图形渲染接口都会提供 GPU 端的缓冲区机制。
缓冲区本质是显存中的一块区域，可以像内存一样存取数据。
不同点是，显存对于 GPU 访问响应速度非常快，对于 CPU 访问响应速度非常慢，而内存反之。
缓冲本身仅用于保存数据，而不关心数据本身的含义，
只有将其绑定到渲染流水线的不同部分时，缓冲才会被赋予不同的意义。
在绘制三角形时，需要先将三角形的顶点信息存入一个缓冲区，
以供渲染流水线调用，这种缓冲区被称作顶点缓冲。

在现代 OpenGL 中，缓冲区需要由程序员手动创建，
赋值。这些操作需要用到如下函数：

\begin{lstlisting}[language=c++]
void glCreateBuffers( GLsizei n, GLuint * buffers );

void glNamedBufferData(
    GLuint buffer,
    GLsizei size,
    const void *data,
    GLenum usage
    );

void glNamedBufferSubData(
    GLuint buffer,
    GLintptr offset,
    GLsizei size,
    const void *data
    );
\end{lstlisting}

glCreateBuffers 用于创建缓冲区对象，并返回创建所对象的标识符。

OpenGL 的对象管理机制并非通过接口类实现，
而是通过标识符实现。
所谓标识符，即一个无符号 32 位整数。
需要对某一对象进行操作时，在调用函数时传入对应的标识符即可表明所操作的对象是哪一个。
因此，在创建某一种对象时，需要调用对应的 glCreate***s 函数获取对应的标识符。
这类函数的调用方法几乎一致，
函数参数为一个整数 $n$ 和一个指向接受标识符的地址空间的指针 $buffers$。
函数会在 $buffers$ 指向的地址空间的前 $n$ 个位置写入 $n$ 个不同的标识符，
指向新创建的 $n$ 个对象。

在只创建一个标识符时，可以这样调用：

\begin{lstlisting}[language=c++]
uint32_t vertex_buffer_object;
glCreateBuffers( 1, &vertex_buffer_object );
\end{lstlisting}

在创建多个标识符时，以 5 个为例，可以这样调用：

\begin{lstlisting}[language=c++]
uint32_t vertex_buffer_objects[5];
glCreateBuffers( 5, vertex_buffer_objects );
\end{lstlisting}

注意，在 OpenGL 函数定义中有许多以 GL 开头的类型，
这是 OpenGL 为了避免在不同平台上原生类型数据长度不统一而设计的。
为了更好地兼容与其他编程库并用时的类型统一性，
建议使用 C/C++ 标准的定长类型替代 GL 类型。
表 \ref{tab-gl:opengl-type} 是一个常用类型之间的简要对照表。

\begin{table}[htbp]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        OpenGL 类型 & 类型实质 & 标准类型\\
        \hline
        GLint & 32 位整型 & int32\_t\\
        \hline
        GLuint & 32 位无符号整型 & uint32\_t\\
        \hline
        GLint64 & 64 位整型 & int64\_t\\
        \hline
        GLuint64 & 64 位无符号整型 & uint64\_t\\
        \hline
        GLbyte & 8 位整型 & int8\_t\\
        \hline
        GLubyte & 8 位无符号整型 & uint8\_t\\
        \hline
        GLenum & 32 位无符号整型 & uint32\_t\\
        \hline
        GLsizei & 32 位整型 & int32\_t\\
        \hline
        GL*ptr & 64 位整型 & int64\_t\\
        \hline
        GLchar & 8 位整型（字符） & int8\_t (char)\\
        \hline
        GLboolean & 8 位无符号整型 & uint8\_t\\
        \hline
        GLfloat & 32 位浮点数（单精度浮点数） & float\\
        \hline
        GLdouble & 64 位浮点数（双精度浮点数） & double\\
        \hline
    \end{tabular}
    \caption{OpenGL 类型对照表}
    \label{tab-gl:opengl-type}
\end{table}

在创建缓冲区对象后，需要使用 glNamedBufferData 函数对新的缓冲区对象创建对应的缓冲区。
函数参数 buffer 表示需要进行创建缓冲区操作的缓冲对象的标识符；
size 表示所要创建的缓冲区的长度，以字节为单位；
data 表示指向用于初始化缓冲区数据的指针，置为 nullptr 则表示不初始化缓冲区的数据；
usage 表示该缓冲区的使用方式特征，需要传入 OpenGL 标准定义的宏。

若想创建一个用于绘制三角形的顶点缓冲区，可以这样调用：

\begin{lstlisting}
glNamedBufferData(
    vertex_buffer_object,
    sizeof(vertex_buffer),
    nullptr,
    GL_STATIC_DRAW);
\end{lstlisting}

其他参数在之前的内容中出现过，不再一一解释。
函数的最后一个参数 GL\_STATIC\_DRAW 表示该缓冲区的数据不会经常被 CPU 写入，
会被经常用于 GPU 端的绘制操作。

这个位置的参数可以看做由两部分组成，首先是表示被访问频率的第一部分，取值有：

1. STATIC；表示很少被 CPU 修改，但会频繁地被 GPU 使用。

2. DYNAMIC；表示经常被 CPU 修改，也会频繁地被 GPU 使用。

3. STREAM；表示很少被 CPU 修改，也只会被 GPU 使用有限的几次，在图形应用中很少会用到。

其次是表示 GPU 端使用方式的第二部分，取值有：

1. DRAW；表示被 CPU 修改，用于 GPU 端的绘制。

2. COPY；表示会被 GPU 端修改，用于 GPU 端的绘制，在图形应用中很少会用到。

3. READ；表示会被 GPU 端修改，用于向 CPU 返回数据，在图形应用中很少会用到。

在常见的 OpenGL 使用情形中，一般将不会每一帧都变换的资源设置为 GL\_STATIC\_DRAW，
将每一帧都很可能发生变化的资源设置为 GL\_DYNAMIC\_DRAW。
此外，这个参数仅表示所创建的缓冲区的使用特征的提示信息，
硬件驱动可能会根据这个参数对数据处理流程做一些优化，
但这个参数不会影响创建出的缓冲区的功能性，仅可能影响缓冲区在执行不同操作时的效率。

在创建好缓冲区后，需要调用 glNamedBufferSubData 函数将 CPU 端的数据上传到缓冲区。
初次上传可以在调用 glNamedBufferData 时完成，但后续的更改需要依赖这个函数。调用方法如下：

\begin{lstlisting}[language=c++]
glNamedBufferSubData(
    vertex_buffer_object,
    0,
    sizeof(vertex_buffer),
    vertex_buffer);
\end{lstlisting}

其中，0 表示缓冲区目标上传位置的偏移量，
sizeof(vertex\_buffer) 表示上传数据的长度，
vertex\_buffer 为 CPU 端数据的起始位置指针。
所示函数调用语句表示把所有顶点数据全部复制到缓冲区中。

如想验证数据是否成功地被复制到缓冲区中，
可以通过 glGetNamedBufferSubData 函数将数据从缓冲区中取回。
调用方法如下：

\begin{lstlisting}
float vertex_buffer_copy[3][8];
glGetNamedBufferSubData(
    vertex_buffer_object,
    0,
    sizeof(vertex_buffer_copy),
    vertex_buffer_copy);
\end{lstlisting}

glGetNamedBufferSubData 函数的参数含义与 glNamedBufferSubData 的基本一致，
区别在于数据流向相反。所示代码将缓冲区中数据复制到了与 CPU 端原数据无关的区域
vertex\_buffer\_copy。
可以通过简单的输入输出手段查看 vertex\_buffer\_copy 中的数据与 vertex\_buffer
是否相同验证数据拷贝是否成功。

本小节着重介绍了三个和缓冲对象相关的 OpenGL 函数，
但 OpenGL 的函数十分繁多，无法在书中一一讲解。
想要了解更多 OpenGL 函数及使用方法，
可以前往 \href{https://docs.gl/}{https://docs.gl/} 进行查询，
这个网站收纳了所有 OpenGL 函数的信息，
包括函数定义，功能，特性，以及支持的版本号等，十分详尽。
后续章节中涉及到的 OpenGL 函数可能不会一一展示函数声明及定义，
如有疑问可以前往该网站进行查询。
（该网站有时在国内访问速度较慢，可以尝试使用网络辅助工具加快访问速度，
在使用网络辅助工具时，请注意遵守相关法律）

更多文档及学习资源请参考 \ref{sec-gl:study-resources} 节。

\subsubsection{着色器}

现代图形渲染接口最显著的特征是对可编程渲染管线的支持。
在以前，绘制复杂的三维场景时只能通过给定的函数接口实现有限的几种渲染效果，
对像素着色的方式也是固定在硬件中的。
这种固定渲染管线的设计虽然可以简化绘制图形的流程，
但难以实现理想的绘制效果。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\linewidth]{imgs/sec 3.2/programmable-rendering-pipeline.png}
    \caption{简化的可编程渲染管线示意图}
    \label{fig-gl:programmable-rendering-pipeline}
\end{figure}

可编程渲染管线的发明极大地拓展了图形硬件的功能，
这种渲染管线的大致流程如图 \ref{fig-gl:programmable-rendering-pipeline} 所示。
图中的流程并非其全貌，而是提取了其中最重要的部分进行示意。
其中用方形框出的阶段是相对固定的，而用椭圆框出的阶段则是可编程的。

现在，由上一小节的内容已经可以得到原始输入的顶点数据，
想要将三角形绘制到屏幕上，需要将原始的顶点数据，
主要是位置坐标，变换到和屏幕对应的二维坐标系上。
否则，硬件设备无法得知该以怎样的方式在屏幕上绘制图形。
这一工作需要由顶点着色器完成。

所谓着色器，即是一些简单的程序块，
类似于常见编程语言中的函数，
只不过这些函数是运行在 GPU，而非 CPU 上的。
这些程序块往往都非常简单，
不会涉及复杂的流程控制，
因而编写起来也十分容易。
比如：顶点着色器最常见的功能就是将原始顶点信息中的三维坐标信息变换成可以直接直接用于绘制的二维坐标；
这一过程的实现会在 \ref{sec-gl:projection-matrix} 小节进行详细说明。
对于目前阶段所要绘制的三角形而言，
由于原始的顶点数据中的坐标已经是二维坐标，
所以这一阶段的顶点着色器只需要将顶点坐标信息原封不动地复制到下一阶段即可。

在 OpenGL 中编写着色器需要用到一种十分类似于 C 语言的着色器语言：
OpenGL 着色器语言（OpenGL Shading Language），简称 GLSL。
使用 GLSL 编写一个实现上述功能的顶点着色器的代码如下：

\begin{lstlisting}
#version 450 core
layout (location = 0) in vec4 vs_pos;
layout (location = 1) in vec4 vs_color;
out vec4 fs_color;
void main()
{
    gl_Position = vs_pos;
    fs_color = vs_color;
}
\end{lstlisting}

代码中的第一行用于声明该着色器所使用的 OpenGL 特性版本，
代码中的 450 即表示 4.5.0 版本。
在不需要用到高版本 OpenGL 特性时，
这个版本声明可以写得小一些，以兼容更多不支持高版本 OpenGL 的设备。
但由于现代图形设备普遍都已支持高版本的 OpenGL，
且 OpenGL 几乎已经停止更新了，
此处将版本信息固定写为 450 也不会产生太多问题。

接下来两行代码用于声明顶点着色器的输入：

layout (location = x) 表示变量对应的数据位置编号，
这一设置与即将在 \ref{sec-gl:fixing-pipeline} 小节介绍的管线配置有关，
现在需要了解的是，顶点的位置信息将被分配到 0 号位置，
顶点的颜色信息将被分配到 1 号位置即可。

in 关键字用于表明接下来定义的是一个输入变量。

vec4 表示变量是一个 4 维向量，
GLSL 中默认所有向量和矩阵的基本元素是单精度浮点数，即 float 类型。
如果希望声明整形向量，可以用 vec4i 这种在变量类型名后添加后缀 i 的方式声明。

vs\_pos 和 vs\_color 为变量名，无需多解释。vs 是顶点着色器的英文名称，Vertex Shader，的缩写。

代码第四行表示着色器的输出，
由于顶点着色器的输出直接对应后续片段着色器的输入（虽然中间隔有一个光栅化阶段），
故只需要保证变量名在两个着色器的代码中一致，即可完成对应，故无需再声明 location 字段。
fs 是片段着色器的英文名称，Fragment Shader，的缩写。

接下来是代码的主体函数，
void main() 为所有用 GLSL 编写的着色器的入口，
形式上与 C 语言极为相似。
在这个着色器中，只实现了两个操作，
即：把顶点的坐标 vs\_pos 信息赋予 OpenGL 内置的用于接收变换后的顶点位置信息的特殊变量 gl\_Position；
以及把顶点的颜色信息原封不动的传给下一阶段的片段着色器。

现在已经有了一个简单的顶点着色器。
数据在经过顶点着色器后会进入光栅化阶段，
光栅化的算法在本书之前的章节已经进行过详细的介绍，
在 GPU 中，存在一种固定的光栅化单元用于高效地完成此部分工作。
经过光栅化后，顶点信息会变为许多片段信息。
一个片段可以简单地理解为一个像素，只不过在一些高级的技术中，可能会有多个片段对应一个像素的情况。
片段在经过处理后最终将变为一个颜色值，用于组成最终的画面。
只不过在刚经过光栅化阶段时，片段还会保留了许多原始数据的信息，
需要通过片段着色器对其进行处理，生成最终的颜色信息。

对于目前渲染一个三角形这个任务而言，片段着色器只需要把从顶点着色器继承的颜色信息赋值到输出端即可，
代码如下：

\begin{lstlisting}
#version 450 core
in vec4 fs_color;
out vec4 color;
void main()
{
    color = fs_color;
}
\end{lstlisting}

这段代码没有涉及新的语法内容，不再展开解释。
需要记住的是，片段着色器的输出只能是 vec4 类型的变量，
表示一个 $(r,g,b,a)$ 四通道颜色信息。
每一维度的范围都是单精度浮点数区间 $[0, 1]$，而非常见 24 位位图的整数区间 $[0,255]$，
后续处理流程会自动完成颜色值区间映射过程。

现在所需的着色器代码都已经备齐了，
接下来需要在 C/C++ 代码中编写创建，编译着色器的代码。
以下代码实现了从文件中读取着色器代码，并编译生成 OpenGL 着色器对象的功能：

\begin{lstlisting}[language=c++]
uint32_t CompileGLSLShaderFromFile(
    const char* shader_file_path,
    uint32_t shader_type
)
{
    FILE* file = nullptr;
#ifdef _WIN32
    fopen_s(&file, shader_file_path, "rb");
#else
    file = fopen(shader_file_path, "rb");
#endif
    if (!file) return 0;
    fseek(file, 0, SEEK_END);
    int64_t length = ftell(file);
    char* source_code = new char[length + 1];
    memset(source_code, 0, length + 1);
    fseek(file, 0, SEEK_SET);
    fread(source_code, 1, length, file);
    fclose(file);

    uint32_t shader_object = glCreateShader(shader_type);
    glShaderSource(shader_object, 1, &source_code, nullptr);
    delete[] source_code;
    glCompileShader(shader_object);

    int32_t compilation_success;
    glGetShaderiv(shader_object, GL_COMPILE_STATUS, &compilation_success);
    if (!compilation_success)
    {
        int32_t log_length;
        glGetShaderiv(shader_object, GL_INFO_LOG_LENGTH, &log_length);
        char* error_info = new char[log_length + 1];
        glGetShaderInfoLog(
            shader_object,
            log_length + 1,
            &log_length,
            error_info);
        std::cout << error_info << std::endl;
        glDeleteShader(shader_object);
        delete [] error_info;
        return 0;
    }

    return shader_object;
}
\end{lstlisting}

这个函数的两个参数中，shader\_file\_path 表示着色器代码保存的位置，
shader\_type 则用于标明着色器类型。
如果是顶点着色器，应传入 GL\_VERTEX\_SHADER；
如果是片段着色器，应传入 GL\_FRAGMENT\_SHADER。

函数代码前半部分负责从指定的文件路径读取着色器代码信息。
涉及到的 OpenGL 函数中，glCreateShader 用于创建 OpenGL 着色器对象，
glShaderSource 用于将着色器代码绑定到着色器对象，
glCompileShader 用于编译着色器对象。
在编译完毕后，如果一切正常，
则着色器创建工作完毕，返回着色器对象的标识符即可。
如果着色器写错了，或者声明的着色器类型错误，
则会导致编译失败。
此时，后续的错误处理代码会将编译错误信息提取出来，输出到控制台，并返回 0。

在样例代码中，上文所示的顶点着色器代码和像素着色器代码被分别保存在项目目录下的
 vertex\_shader.glsl 和 fragment\_shader.glsl 文件中。
调用上述函数生成着色器对象的代码如下：

\begin{lstlisting}[language=c++]
uint32_t vertex_shader_object =
    CompileGLSLShaderFromFile("vertex_shader.glsl", GL_VERTEX_SHADER);
uint32_t fragment_shader_object =
    CompileGLSLShaderFromFile("fragment_shader.glsl", GL_FRAGMENT_SHADER);
\end{lstlisting}

如果编译错误，比如在着色器代码中将变量名写错，
编译运行程序后则会出现如下错误提示（错误提示可能因 GPU 生产商的不同或驱动不同产生差异）：

\begin{lstlisting}
0(7) : error C1503: undefined variable "gl_Pos"
\end{lstlisting}

此处错误原因是，误把内置变量 gl\_Position 写成 gl\_Pos。

在着色器编译完成后，
还需要将不同阶段的着色器（Shader）链接成一个着色器程序（Program），
才能在流水线中使用。代码如下：

\begin{lstlisting}
uint32_t LinkProgram(uint32_t vs_object, uint32_t fs_object)
{
    uint32_t program_object = glCreateProgram();
    glAttachShader(program_object, vs_object);
    glAttachShader(program_object, fs_object);
    glLinkProgram(program_object);
    int32_t link_success;
    glGetProgramiv(program_object, GL_LINK_STATUS, &link_success);
    if (!link_success)
    {
        int32_t log_length;
        glGetProgramiv(program_object, GL_INFO_LOG_LENGTH, &log_length);
        char * error_info = new char [log_length + 1];
        glGetProgramInfoLog(
            program_object,
            log_length + 1,
            &log_length,
            error_info);
        std::cout << error_info << std::endl;
        glDeleteProgram(program_object);
        delete[] error_info;
        return 0;
    }
    return program_object;
}
\end{lstlisting}

这个函数可以接受一个顶点着色器标识符和一个片段着色器标识符，
链接生成一个着色器程序，并自动处理链接错误的情况。
当一切正常时，该函数会返回一个着色器程序的标识符。
否则，输出错误信息并返回 0。该函数的调用方法如下：

\begin{lstlisting}[language=c++]
shader_program_object =
    LinkProgram(vertex_shader_object, fragment_shader_object);
\end{lstlisting}

当出现错误时，比如在顶点着色器中误把输出变量名 fs\_color 写成 ps\_color，会出现如下错误提示：

\begin{lstlisting}
Link info
---------
error: "fs_color" not declared as an output from the previous stage
\end{lstlisting}

在成功链接着色器程序后，如着色器对象不会再被使用，可以将其删除以节约资源。

\begin{lstlisting}
glDeleteShader(vertex_shader_object);
glDeleteShader(fragment_shader_object);
\end{lstlisting}

\subsubsection{配置管线}

\label{sec-gl:fixing-pipeline}

如果以上步骤都已经完成且没有发生错误，
至此所有绘制一个三角形所需的资源都已经备齐了。
接下来需要做的就是将准备好的资源，
包括顶点缓冲和着色器程序，
绑定到渲染流水线上，
并渲染出来。

首先需要设置绘制的“视口（Viewport）”，
即窗口中绘制图形的区域，
以像素为单位进行指定。
本例将把图形绘制到整个窗口中，
故视口区域将被设置为窗口大小。
代码如下：

\begin{lstlisting}
int32_t width, height;
glfwGetWindowSize(window, &width, &height);
glViewport(0, 0, width, height);
\end{lstlisting}

其中 glfwGetWindowSize 用于获取窗口大小，glViewport 用于设置视口。

然后是着色器程序。着色器程序是渲染管线中最重要的部分，
它决定了绘制图形的方式。
调用 glUseProgram 函数将着色器程序对象设置为当前使用的着色器程序。

\begin{lstlisting}
glUseProgram(shader_program_object);
\end{lstlisting}

接下来，使用 glBindBuffer 函数将顶点缓冲区对象绑定到流水线顶点缓冲的绑定点。

\begin{lstlisting}
glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer_object);
\end{lstlisting}

OpenGL 接口标准定义了许多缓冲绑定点，
这个函数可以将缓冲区对象绑定到不同的缓冲绑定点，
代码中的 GL\_ARRAY\_BUFFER 是用于声明顶点缓冲绑定点的宏常量，
除此之外，经常被使用的还有索引缓冲绑定点 GL\_ELEMENT\_ARRAY\_BUFFER。

在顶点缓冲绑定完成后，需要将顶点缓冲中的数据对应到顶点着色器的输入。
这一步可以使用 glVertexAttribPointer 函数完成此项工作。方法如下：

\begin{lstlisting}
glVertexAttribPointer(0, 4, GL_FLOAT, false, 32, (void*)0);
glVertexAttribPointer(1, 4, GL_FLOAT, false, 32, (void*)16);
\end{lstlisting}

以上函数每一项参数对应的含义如图 \ref{fig-gl:vertex-attrib} 所示。

第一个参数 index 对应了顶点着色器中的 layout (location = x) 字段，
用于声明保定数据的位置；

第二个参数 size 对应了着色器输入变量类型含有的元素个数，
如：四维向量 vec4 含有 $4$ 个元素，
$4\times 4$ 的矩阵 mat4 含有 $16$ 个元素。

第三个参数 type 对应了元素类型，此例中为 float 类型，对应 OpenGL 标准宏常量为 GL\_FLOAT。
此外还有 GL\_DOUBLE，GL\_INT, GL\_UNSIGNED\_INT, GL\_BYTE，GL\_UNSIGNED\_BYTE 等参数可选。

第四个参数 normalized 表示是否要对数据进行归一化处理，一般置为 false。

第五个参数 stride 表示从一组数据到下一组数据，起始位置相差多少个字节；
一般使用一个顶点数据的大小。当前一个顶点使用了 8 个 float，总共为 32 字节。

第六个参数 pointer 表示当前位置的数据相对一组数据的起始点的偏移量。
比如位置数据前方没有数据，则为 0；颜色数据在位置数据之后，而位置数据占据 16 个字节，故为 16。
此处参数虽然要求为指针类型，但实际作用方式和整数标量无异。

\begin{figure}[htbp]
\centering
\includegraphics[width=0.8\linewidth]{imgs/sec 3.3/vertex-attrib.png}
\caption{glVertexAttribPointer 函数参数对照关系示意图}
\label{fig-gl:vertex-attrib}
\end{figure}

在绑定好每个位置的顶点数据后，还要将用到的位置激活，调用以下函数实现：

\begin{lstlisting}
glEnableVertexAttribArray(0);
glEnableVertexAttribArray(1);
\end{lstlisting}

注意：存在一个与函数 glEnableVertexAttribArray 名称十分相似的函数 glEnableVertexArrayAttrib，
但功能并不相同，应当避免混淆。

至此，渲染一个三角形所需要进行的管线信息配置已经全部完成，
调用函数 glDrawArrays 即可渲染出三角形。方法如下：

\begin{lstlisting}
glDrawArrays(GL_TRIANGLES, 0, 3);
\end{lstlisting}

函数第一个参数用于指定绘制模式。
GL\_TRIANGLES 表示将顶点按照三个一组的方式组成三角形绘制。
除此之外，还可以尝试以下模式：

\begin{table}[htbp]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        GL\_POINTS&绘制点（可能会很难看清）\\
        \hline
        GL\_LINE\_STRIP&绘制直线带\\
        \hline
        GL\_LINE\_LOOP&绘制直线环\\
        \hline
    \end{tabular}
    \caption{OpenGL 绘制模式对照表}
\end{table}

函数第二个参数表示绘制起始顶点的编号，置为 0 表示从头开始。

函数第三个参数表示总共参与绘制的顶点数量。

如果没有发生问题，此时编译运行程序应该能够看到被绘制出的三角形。如图 \ref{fig-gl:hello-triangle} 所示。

\begin{figure}[htbp]
\centering
\includegraphics[width=0.5\linewidth]{imgs/sec 3.3/hello-triangle.png}
\caption{你好，三角形}
\label{fig-gl:hello-triangle}
\end{figure}

\subsection{绘制立方体}

成功绘制出一个三角形，
就已经完成了走向高性能图形绘制最重要的一步。
本章节要达成的目标，是从二次元走向三次元。
更高的维数可以设计更复杂的场景，
带来了更高的“可玩性”，
走向三维也是连接虚拟和现实世界的必经之路。
实现这个目标可谓意义重大。

具体来说，本章节最终将实现利用 OpenGL 绘制一个具有立体感的立方体。
之所以选择立方体，是因为立方体能够比较好地体现三维渲染的特点，
描述一个立方体又相对简单。
故许多图形绘制教程都会选择立方体作为三维图形绘制的例子，
本书也不例外。

\subsubsection{坐标变换}

\label{sec-gl:coordinate-transform}

立方体可以由空间中的 12 个三角形组成，
用上一章节中的方法将这 12 个三角形合理地绘制出来，
目标就达成了。
但空间中的三角形使用的是三维顶点坐标，
绘制三角形需要的是和屏幕所在平面相关的二维坐标。
在绘制空间中的三角形之前，
需要先将空间中的三角形对应到屏幕上的三角形。

但这种对应关系并不唯一，它受许多因素影响。
想象一个人围着一个摆在桌子上的三角形转一圈，
然后自身再转一圈，再走远。
这个过程中，
这个人看到的三角形的形状，大小，位置，甚至能否看到三角形这个状态都会随着人的移动发生变化。
这还没有考虑到三角形自身的移动和变化等等问题。
这些问题可以统一地归纳为坐标变换问题。

要考虑坐标变换问题，需要先将问题分为两部分。
一部分是空间坐标到空间坐标的变换。
比如物体的移动，整体拉伸，旋转等。
根据一些简单的线性代数和几何知识可以明白，
物体在空间中发生的移动，整体拉伸，旋转等变化，
都属于放射变换。
而仿射变换又都可以通过线性操作完成，
因此，这部分由空间坐标到空间坐标的变换是容易解决的。
如果遇到特殊的非线性空间坐标变换，
可以具体问题具体分析，无法一概而论。

到此为止，经过一系列空间坐标到空间坐标的变换后，
可以视所有空间坐标为以观察者所处位置及方向所形成的的坐标系中的坐标。
所谓观察者，可以想象成一个相机，或者眼睛，有所处位置及上下左右前后之分，
故可以用一个坐标系表示空间中物体相对于观察者的位置关系，
这个坐标系被称作观察坐标系。

坐标变换的第二部分是从空间坐标到屏幕坐标的变换，是实现三维图形绘制最为精妙的部分。
想象一个拥有变化的视野范围的观察者，
例如一个可调节倍率的望远镜（假设倍率可以从 1.0x 调节到 $\infty$x）。
其观察到的图像也会随着视野的变化而发生变化，
当图像大小一定时，低视野范围的观察者观察到的图形就会显得大。
再想象出一个可以穿墙的观察者从远处开始面朝一堵面积有限的墙移动，
直至穿过这堵墙。
墙会先随着观察者距离的逼近逐渐变大，然后在穿墙的瞬间消失。
再例如，距离近的静止物体在观察者移动时，在观察者的视野中移动速度快，
而远距离的物体在观察者视野中移动速度慢。
通过以上观察不难得出结论，从空间坐标到屏幕坐标的变换具有非线性性，
因此描述这种变换相对困难一些。

描述这种变换需要先对视觉形成的过程进行分析。
首先，观察者所处位置被称为“视点”。
从视点出发，以视野范围为限，
向视野内各个方向发出射线，所形成的锥形区域，称作“视锥”。
在现实世界中，无论是眼睛还是相机镜头，
视觉成像的本质是视锥内的物体在“感光区域”所形成的投影。
现实世界中投影的过程还需要由一个凸透镜进行聚光，
但在进行三维图形绘制的坐标变换时，不需要考虑如此复杂。



\subsubsection{标准化设备坐标空间}

\subsubsection{投影矩阵}

\label{sec-gl:projection-matrix}



\subsubsection{uniform 变量}

\subsubsection{索引缓冲}

\subsubsection{深度缓冲}

\subsubsection{最终效果}

\subsection{纹理贴图}

\subsubsection{加载纹理}

\subsubsection{绘制纹理}

\subsection{光照}

\subsubsection{实现基于 BRDF 的光照}

\subsubsection{绘制阴影}

\subsection{绘制到纹理}

\subsubsection{帧缓冲}

\subsection{更多学习资源}

\label{sec-gl:study-resources}

\href{https://docs.gl}{docs.gl，OpenGL 函数资料库：https://docs.gl/}

\href{https://learnopengl.com/}{Learn OpenGL，一个出色的 OpenGL 教程：https://learnopengl.com/}

\href{https://learnopengl-cn.github.io/}{Learn OpenGL 中文翻译版：https://learnopengl-cn.github.io/}

\end{document}
